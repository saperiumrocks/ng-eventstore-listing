{
  "version": 3,
  "file": "ng-eventstore-listing.umd.min.js",
  "sources": [
    "ng://ng-eventstore-listing/node_modules/tslib/tslib.es6.js",
    "ng://ng-eventstore-listing/out/services/script.service.ts",
    "ng://ng-eventstore-listing/out/utils/helpers.ts",
    "ng://ng-eventstore-listing/out/services/push.service.ts",
    "ng://ng-eventstore-listing/out/services/playback.service.ts",
    "ng://ng-eventstore-listing/out/services/playback-list.service.ts",
    "ng://ng-eventstore-listing/out/ng-eventstore-listing.component.ts",
    "ng://ng-eventstore-listing/out/directives/template.directive.ts",
    "ng://ng-eventstore-listing/out/components/item-template-holder/item-template-holder.component.ts",
    "ng://ng-eventstore-listing/out/services/socket.io.service.ts",
    "ng://ng-eventstore-listing/out/ng-eventstore-listing.module.ts",
    "ng://ng-eventstore-listing/out/components/template-components/item-template/item-template.component.ts",
    "ng://ng-eventstore-listing/out/enums/filter-operator.ts",
    "ng://ng-eventstore-listing/out/enums/sort-direction.ts",
    "ng://ng-eventstore-listing/out/enums/group-boolean-operator.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n",
    "import { Injectable } from '@angular/core';\nimport { Script } from '../models';\n\ndeclare var document: any;\n\n@Injectable()\nexport class ScriptService {\n  private scripts: any = {};\n\n  constructor() {}\n\n  async init(scriptStore: Script[]) {\n    const promises = [];\n    scriptStore.forEach((script: Script) => {\n      // console.log('SCRIPT STORE LOGGING');\n      this.scripts[script.name] = {\n        loaded: false,\n        src: script.src,\n        meta: script.meta,\n      };\n      promises.push(this.load(script.name));\n    });\n\n    return await Promise.all(promises);\n  }\n\n  async load(...scripts: string[]): Promise<any> {\n    const promises: any[] = [];\n    scripts.forEach((script) => promises.push(this.loadScript(script)));\n    return await Promise.all(promises);\n  }\n\n  loadScript(name: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // resolve if already loaded\n      if (this.scripts[name].loaded) {\n        // console.log('LOADED');\n        resolve({\n          script: name,\n          loaded: true,\n          status: 'Already Loaded',\n          meta: this.scripts[name].meta,\n        });\n      } else {\n        const existingScript = document.querySelectorAll(`head script[src=\"${this.scripts[name].src}\"]`);\n        if (existingScript.length === 0) {\n          // load script\n          const script = document.createElement('script');\n          script.type = 'text/javascript';\n          script.src = this.scripts[name].src;\n          if (script.readyState) {\n            // IE\n            script.onreadystatechange = () => {\n              // console.log('ON READYSTATECHANGE');\n              if (\n                script.readyState === 'loaded' ||\n                script.readyState === 'complete'\n              ) {\n                script.onreadystatechange = null;\n                this.scripts[name].loaded = true;\n                resolve({\n                  script: name,\n                  loaded: true,\n                  status: 'Loaded',\n                  meta: this.scripts[name].meta,\n                });\n              }\n            };\n          } else {\n            // Others\n            // console.log('ONLOAD');\n            script.onload = () => {\n              this.scripts[name].loaded = true;\n              resolve({\n                script: name,\n                loaded: true,\n                status: 'Loaded',\n                meta: this.scripts[name].meta,\n              });\n            };\n          }\n          script.onerror = (error: any) =>\n          console.log('ON ERROR', error);\n            resolve({\n              script: name,\n              loaded: false,\n              status: 'Loaded',\n              meta: this.scripts[name].meta,\n            });\n          document.getElementsByTagName('head')[0].appendChild(script);\n        } else {\n          // console.log('Script already exists');\n          resolve();\n        }\n      }\n    });\n  }\n\n  getScript(scriptName: string) {\n    return this.scripts[scriptName];\n  }\n}\n",
    "export const Helpers = {\n  generateToken: () => {\n    return Math.random().toString(36).substr(2, 9) + '-' + Date.now().toString();\n  }\n};\n",
    "import { Injectable } from '@angular/core';\nimport { Helpers } from '../utils/helpers.js';\nimport _forOwn from 'lodash-es/forOwn';\nimport _clone from 'lodash-es/clone';\nimport * as io from 'socket.io-client';\n\n@Injectable()\nexport class PushService {\n  private ioPush: any;\n  private subscriptions: any = {};\n  constructor() { }\n\n  init(socketUrl: string) {\n    if (!this.ioPush) {\n      this.ioPush = io.connect(`${socketUrl}/events`);\n\n      this.ioPush.on('message', (eventObj) => {\n        this._processEvent(eventObj);\n      });\n\n      this.ioPush.on('reconnect', () => {\n        // console.log('TEST RECONNECTION');\n        // this.ioPush.emit('resubscribe', () => {\n          // console.log(this.subscriptions);\n          _forOwn(this.subscriptions, (sub) => {\n            const subscriptionQuery = Object.assign(sub.query, {\n              offset: sub.offset,\n            });\n\n            this.ioPush.emit('subscribe', subscriptionQuery, (token: string) => {\n              if (token) {\n                // console.log('Reconnected:', token, subscriptionQuery);\n                sub.token = token;\n              } else {\n                console.error('Reconnect error for query', subscriptionQuery);\n              }\n            });\n          });\n        // });\n      });\n    }\n  }\n\n  _processEvent(eventObj: any) {\n    const self = this;\n    // console.log('got message from push server: ', eventObj);\n    const queryKey = `${eventObj.context}.${eventObj.aggregate}.${eventObj.aggregateId}`;\n    const clientTokens = Object.keys(self.subscriptions);\n    // redirect to mapped subscription/token callback\n    clientTokens.forEach((clientToken) => {\n      const sub = self.subscriptions[clientToken];\n      if (sub) {\n        const subQueryKey = `${sub.query.context}.${sub.query.aggregate}.${sub.query.aggregateId}`;\n        if (subQueryKey === queryKey) {\n          // update next offset (from stream revision) for this subscription, so for reconnecting\n          if (!isNaN(eventObj.streamRevision)) {\n            sub.offset = eventObj.streamRevision + 1;\n          }\n          if (typeof sub.cb === 'function') {\n            sub.cb(undefined, eventObj, sub.owner, clientToken);\n          }\n\n          // iterate on monitors meta tags\n          const tags = Object.keys(sub.monitorTags);\n          tags.forEach((tag) => {\n            // check for state/eventSource._meta or event._meta\n            if (eventObj._meta && eventObj._meta.tag === tag) {\n              let reason = 'N/A';\n              if (typeof eventObj.eventType === 'string') {\n                reason = eventObj.eventType;\n              } else if (typeof eventObj.stateType === 'string') {\n                reason = eventObj.stateType;\n                if (\n                  eventObj.eventSource &&\n                  typeof eventObj.eventSource.eventType === 'string'\n                ) {\n                  reason += ` <- ${eventObj.eventSource.eventType}`;\n                }\n              }\n              // iterate on the monitors\n              const monitors = sub.monitorTags[tag];\n              monitors.forEach((monitor) => {\n                monitor.callback(reason, eventObj._meta);\n              });\n            }\n          });\n        }\n      }\n    });\n  }\n\n  subscribe(query, offset, owner, cb) {\n    // await this.waitForSocketConnection();\n    const pushToken = Helpers.generateToken();\n    // map new subscription, then try to subscribe to server asap\n    this.subscriptions[pushToken] = {\n      query: query,\n      offset: offset,\n      owner: owner,\n      cb: cb,\n      monitorTags: {},\n    };\n\n    const sub = this.subscriptions[pushToken];\n    if (sub && !sub.token) {\n      // build up proper subscribe request query\n      const subscriptionQuery = Object.assign(sub.query, {\n        offset: sub.offset,\n      });\n\n      this.ioPush.emit('subscribe', subscriptionQuery, ({ subscriptionToken, catchUpEvents }) => {\n        if (subscriptionToken) {\n          // console.log('Server Subscribed:', token, subscriptionQuery);\n          sub.token = subscriptionToken;\n        } else {\n          console.error('Subscribe error for query', subscriptionQuery);\n        }\n\n        if (catchUpEvents && catchUpEvents.length > 0) {\n          catchUpEvents.forEach((event) => {\n            cb(undefined, event, owner, pushToken);\n          });\n        }\n      });\n    }\n\n    return pushToken;\n  }\n\n  unsubscribe(pushTokens: string[]): Promise<void> {\n    const socketTokens = [];\n\n    pushTokens.forEach((pushToken) => {\n      if (this.subscriptions[pushToken]) {\n        const clientSubscription = _clone(this.subscriptions[pushToken]);\n        delete this.subscriptions[pushToken];\n\n        const sub = clientSubscription;\n        if (sub && sub.token) {\n          socketTokens.push(sub.token);\n        }\n      }\n    });\n\n    return new Promise((resolve, reject) => {\n      this.ioPush.emit('unsubscribe', socketTokens, () => {\n        resolve();\n      });\n    });\n  }\n}\n",
    "import { Helpers } from './../utils/helpers';\nimport { Injectable } from '@angular/core';\nimport { ScriptService } from './script.service';\nimport { PushService } from './push.service';\nimport {\n  StateFunctions,\n  PlaybackList,\n  PlaybackRegistry,\n  Query,\n  ConditionalSubscriptionRegistry,\n} from '../models';\n\n@Injectable()\nexport class PlaybackService {\n  _playbackRegistry: PlaybackRegistry = {};\n  _conditionalSubscriptionRegistry: ConditionalSubscriptionRegistry = {};\n\n  constructor(\n    private scriptService: ScriptService,\n    private pushService: PushService\n  ) {}\n\n  init(socketUrl: string) {\n    this.pushService.init(socketUrl);\n  }\n\n  async unregisterForPlayback(playbackTokens: string[]) {\n    // unregister from playback registry\n    const pushTokens = playbackTokens.map((playbackToken) => {\n      return this._playbackRegistry[playbackToken].pushSubscriptionId;\n    });\n\n    playbackTokens.forEach(async (token) => {\n      const rowId = this._playbackRegistry[token].rowId;\n\n      console.log('BEFORE');\n      console.log(this._conditionalSubscriptionRegistry);\n\n      if (rowId) {\n        delete this._conditionalSubscriptionRegistry[rowId];\n      }\n\n      console.log('AFTER');\n      console.log(this._conditionalSubscriptionRegistry);\n\n      // unsubscribe from push\n      delete this._playbackRegistry[token];\n    });\n\n    await this.pushService.unsubscribe(pushTokens);\n  }\n\n  async registerForPlayback(\n    owner: object,\n    scriptName: string,\n    query: Query,\n    stateFunctions: StateFunctions,\n    playbackList: PlaybackList,\n    streamRevisionFunction: (item: any) => number = (item) => 0,\n    rowId?: string,\n    conditionFunction?: (item: any) => boolean\n  ) {\n    const playbackSubscriptionId = Helpers.generateToken();\n\n    let rowData;\n    if (rowId) {\n      const aggregateId = rowId ? rowId : query.aggregateId;\n      rowData = await new Promise((resolve, reject) => {\n        playbackList.get(aggregateId, (error, item) => {\n          if (error) {\n            reject(error);\n          }\n          resolve(item);\n        });\n      });\n    }\n\n    let streamRevision;\n    let isConditionTrue;\n\n    if (rowData) {\n      streamRevision = streamRevisionFunction(rowData);\n      isConditionTrue = conditionFunction ? conditionFunction(rowData) : undefined;\n    }\n\n    let pushSubscriptionId;\n    if (isConditionTrue === true || conditionFunction === undefined) {\n      pushSubscriptionId = await this.pushService.subscribe(\n        query,\n        streamRevision,\n        this,\n        async (err, eventObj, owner2) => {\n          // owner is playbackservice\n          const self = owner2 as PlaybackService;\n\n          console.log(self._playbackRegistry);\n\n          const registration = self._playbackRegistry[playbackSubscriptionId];\n\n          if (registration) {\n            if (eventObj.aggregate === 'states') {\n              const thisScriptName = registration.scriptName;\n              const fromEvent = eventObj.payload._meta.fromEvent;\n              const eventName = fromEvent.payload.name;\n              const thisPlaybackScript = window[thisScriptName];\n              const playbackFunction = thisPlaybackScript.playbackInterface[eventName];\n\n            if (playbackFunction) {\n              if (registration.rowId) {\n                eventObj.aggregateId = registration.rowId;\n              }\n              const state = eventObj.payload;\n              const funcs = {\n                emit: (targetQuery, payload, done) => {\n                  done();\n                },\n                getPlaybackList: (\n                  playbackListName: string,\n                  callback: (err, playbackList: PlaybackList) => void\n                ) => {\n                  if (registration.playbackList) {\n                    callback(null, registration.playbackList);\n                  } else {\n                    callback(\n                      new Error(\n                        'PlaybackList does not exist in this registration'\n                      ),\n                      null\n                    );\n                  }\n                },\n              };\n\n              const doneCallback = () => {\n                registration.playbackList.get(eventObj.aggregateId, (error, item) => {\n                  self._updateConditionalSubscriptions(eventObj.aggregateId, item);\n                });\n              };\n\n              playbackFunction(state, fromEvent, funcs, doneCallback);\n            }\n            } else {\n              const thisScriptName = registration.scriptName;\n              const thisPlaybackScript = window[thisScriptName];\n              const playbackFunction = thisPlaybackScript.playbackInterface[eventObj.payload.name];\n\n              if (playbackFunction) {\n                // Override aggregateId to handle other subscriptions\n                if (registration.rowId) {\n                  eventObj.aggregateId = registration.rowId;\n                }\n                const row = stateFunctions.getState(eventObj.aggregateId);\n                const state = row.data;\n                const funcs = {\n                  emit: (targetQuery, payload, done) => {\n                    done();\n                  },\n                  getPlaybackList: (\n                    playbackListName: string,\n                    callback: (err, playbackList: PlaybackList) => void\n                  ) => {\n                    if (registration.playbackList) {\n                      callback(null, registration.playbackList);\n                    } else {\n                      callback(\n                        new Error(\n                          'PlaybackList does not exist in this registration'\n                        ),\n                        null\n                      );\n                    }\n                  },\n                };\n\n                const doneCallback = () => {\n                  registration.playbackList.get(eventObj.aggregateId, (error, item) => {\n                    self._updateConditionalSubscriptions(eventObj.aggregateId, item);\n                  });\n                };\n\n                playbackFunction(state, eventObj, funcs, doneCallback);\n              }\n            }\n          }\n        }\n      );\n    }\n\n    // If condition exists, register in conditional registry\n    if (conditionFunction) {\n      if (this._conditionalSubscriptionRegistry[rowId] && Array.isArray(this._conditionalSubscriptionRegistry[rowId])) {\n        this._conditionalSubscriptionRegistry[rowId].push({\n          playbackList: playbackList,\n          scriptName: scriptName,\n          owner: owner,\n          stateFunctions: stateFunctions,\n          query: query,\n          streamRevisionFunction: streamRevisionFunction,\n          conditionFunction: conditionFunction,\n          pushSubscriptionId: pushSubscriptionId,\n          playbackSubscriptionId: playbackSubscriptionId\n        });\n      } else {\n        this._conditionalSubscriptionRegistry[rowId] = [{\n          playbackList: playbackList,\n          scriptName: scriptName,\n          owner: owner,\n          stateFunctions: stateFunctions,\n          query: query,\n          streamRevisionFunction: streamRevisionFunction,\n          conditionFunction: conditionFunction,\n          pushSubscriptionId: pushSubscriptionId,\n          playbackSubscriptionId: playbackSubscriptionId\n        }];\n      }\n    }\n\n    this._playbackRegistry[playbackSubscriptionId] = {\n      owner: owner,\n      pushSubscriptionId: pushSubscriptionId,\n      playbackList: playbackList,\n      scriptName: scriptName,\n      rowId: rowId\n    };\n\n    return playbackSubscriptionId;\n  }\n\n  _updateConditionalSubscriptions(rowId, rowData) {\n    const conditionalSubscriptions = this._conditionalSubscriptionRegistry[rowId] || [];\n    conditionalSubscriptions.forEach(async (conditionalSubscription) => {\n      if (!conditionalSubscription.pushSubscriptionId && conditionalSubscription.conditionFunction(rowData)) {\n        const offset = conditionalSubscription.streamRevisionFunction(rowData);\n        const pushSubscriptionId = this.pushService.subscribe(\n          conditionalSubscription.query,\n          offset,\n          this,\n          async (err, eventObj, owner2) => {\n            // owner is playbackservice\n            const self = owner2 as PlaybackService;\n            const registration = self._playbackRegistry[conditionalSubscription.playbackSubscriptionId];\n\n            if (eventObj.aggregate === 'states') {\n              const thisScriptName = registration.scriptName;\n              const fromEvent = eventObj.payload._meta.fromEvent;\n              const eventName = fromEvent.payload.name;\n              const thisPlaybackScript = window[thisScriptName];\n              const playbackFunction = thisPlaybackScript.playbackInterface[eventName];\n\n              if (playbackFunction) {\n                const state = eventObj.payload;\n                const funcs = {\n                  emit: (targetQuery, payload, done) => {\n                    done();\n                  },\n                  getPlaybackList: (\n                    playbackListName: string,\n                    callback: (err, playbackList: PlaybackList) => void\n                  ) => {\n                    if (registration.playbackList) {\n                      callback(null, registration.playbackList);\n                    } else {\n                      callback(\n                        new Error(\n                          'PlaybackList does not exist in this registration'\n                        ),\n                        null\n                      );\n                    }\n                  },\n                };\n\n                const doneCallback = () => {\n                };\n                playbackFunction(state, fromEvent, funcs, doneCallback);\n              }\n            } else {\n\n              const thisScriptName = registration.scriptName;\n              const thisPlaybackScript = window[thisScriptName];\n              const playbackFunction = thisPlaybackScript.playbackInterface[eventObj.payload.name];\n\n              if (playbackFunction) {\n                // Override aggregateId to handle other subscriptions\n                if (registration.rowId) {\n                  eventObj.aggregateId = registration.rowId;\n                }\n                const row = conditionalSubscription.stateFunctions.getState(eventObj.aggregateId);\n                const state = row.data;\n                const funcs = {\n                  emit: (targetQuery, payload, done) => {\n                    done();\n                  },\n                  getPlaybackList: (\n                    playbackListName: string,\n                    callback: (err, playbackList: PlaybackList) => void\n                  ) => {\n                    if (registration.playbackList) {\n                      callback(null, registration.playbackList);\n                    } else {\n                      callback(\n                        new Error(\n                          'PlaybackList does not exist in this registration'\n                        ),\n                        null\n                      );\n                    }\n                  },\n                };\n\n                const doneCallback = () => {\n                  // stateFunctions.setState(row.rowId, row);\n                };\n\n                playbackFunction(state, eventObj, funcs, doneCallback);\n              }\n            }\n          }\n        );\n\n        // just use the subscriptionId to map the push subscription to the playback\n        this._playbackRegistry[conditionalSubscription.playbackSubscriptionId] = {\n          owner: conditionalSubscription.owner,\n          pushSubscriptionId: pushSubscriptionId,\n          playbackList: conditionalSubscription.playbackList,\n          scriptName: conditionalSubscription.scriptName,\n          rowId: rowId\n        };\n\n        conditionalSubscription.pushSubscriptionId = pushSubscriptionId;\n\n        // console.log('subscribed to playback: ', pushSubscriptionId, conditionalSubscription.query);\n        return pushSubscriptionId;\n      } else if (!conditionalSubscription.conditionFunction(rowData) && conditionalSubscription.pushSubscriptionId) {\n        this.pushService.unsubscribe([conditionalSubscription.pushSubscriptionId]).then(() => {\n          delete this._playbackRegistry[conditionalSubscription.playbackSubscriptionId];\n          conditionalSubscription.pushSubscriptionId = undefined;\n        });\n      }\n    });\n  }\n\n}\n",
    "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs/Observable';\nimport { Filter, Sort, PlaybackListResponse } from '../models';\n\n@Injectable()\nexport class PlaybackListService {\n  constructor(private http: HttpClient) {}\n\n  getPlaybackList(\n    playbackListBaseUrl: string,\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort[]\n  ): Observable<PlaybackListResponse> {\n    let url = `${playbackListBaseUrl}/playback-list/${playbackListName}?startIndex=${startIndex}&limit=${limit}`;\n\n    if (filters) {\n      url += `&filters=${JSON.stringify(filters)}`;\n    }\n\n    if (sort) {\n      url += `&sort=${JSON.stringify(sort)}`;\n    }\n\n    return this.http.get<PlaybackListResponse>(url);\n  }\n\n  getPlaybackListCsv(\n    playbackListBaseUrl: string,\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort[],\n    type?: string\n  ): Observable<any> {\n    let url = `${playbackListBaseUrl}/playback-list/${playbackListName}/export?startIndex=${startIndex}&limit=${limit}`;\n\n    if (filters) {\n      url += `&filters=${JSON.stringify(filters)}`;\n    }\n\n    if (sort) {\n      url += `&sort=${JSON.stringify(sort)}`;\n    }\n\n    if (type) {\n      url += `&type=${type}`;\n    }\n\n    return this.http.get<PlaybackListResponse>(url);\n  }\n}\n",
    "import {\n  Component,\n  OnInit,\n  Input,\n  Output,\n  EventEmitter,\n  OnChanges,\n  SimpleChanges,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  OnDestroy,\n} from '@angular/core';\n\nimport { switchMap, debounceTime } from 'rxjs/operators';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Subject } from 'rxjs/Subject';\n\nimport {\n  SubscriptionConfiguration,\n  Script,\n  PlaybackList,\n  RowItem,\n  Filter,\n  Query,\n  Sort,\n  PlaybackListRequest,\n} from './models';\n\n\nimport { ScriptService } from './services/script.service';\nimport { PlaybackService } from './services/playback.service';\nimport { PlaybackListService } from './services/playback-list.service';\n\nimport * as Immutable from 'immutable';\nimport _defaultsDeep from 'lodash-es/defaultsDeep';\nimport _isEmpty from 'lodash-es/isEmpty';\nimport _isEqual from 'lodash-es/isEqual';\nimport _cloneDeep from 'lodash-es/cloneDeep';\nimport _clone from 'lodash-es/clone';\nimport _uniq from 'lodash-es/uniq';\nimport _merge from 'lodash-es/defaults';\nimport * as moment_ from 'moment-mini-ts';\n\nimport saveAs from 'file-saver';\n\n@Component({\n  selector: 'lib-ng-eventstore-listing',\n  template: `<!-- <div *ngIf=\"listHeaderGroups && listHeaderGroups.groups && listHeaderGroups.groups.length > 0\"  [class]=\"'row ' + (listHeaderGroups && listHeaderGroups.generalRowClassName ? listHeaderGroups.generalRowClassName : '')\">\n  <div class=\"col-12\">\n    <div class=\"header bg-white p-2\">\n      <div [class]=\"'row ' + listHeaderGroups.generalRowClassName\">\n        <div *ngFor=\"let listHeaderGroup of listHeaderGroups.groups\" [class]=\"listHeaderGroup.className\">\n          <div [class]=\"'row ' + listHeaderGroups.generalRowClassName\">\n            <div *ngFor=\"let listHeader of listHeaderGroup.listHeaders\" [class]=\"listHeader.className\">\n              <span (click)=\"onSort(listHeader.sortProperty)\" [ngClass]=\"{ 'sort-header': listHeader.sortProperty }\">{{ listHeader.displayName }} <i *ngIf=\"sortFields[listHeader.sortProperty] && sortFields[listHeader.sortProperty].icon\" [class]=\"'sort-icon ' + sortFields[listHeader.sortProperty].icon\"></i></span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div> -->\n<!-- <div [class]=\"'row ' + (listHeaderGroups && listHeaderGroups.generalRowClassName) ? listHeaderGroups.generalRowClassName : ''\" *ngFor=\"let item of dataList; trackBy: trackByFn\"> -->\n<div class=\"row\" *ngFor=\"let item of _dataList; trackBy: trackByFn\">\n  <div class=\"col-12\">\n    <lib-item-template-holder\n      [data]=\"item\"\n      [itemComponentClass]=\"itemComponentClass\"\n      [lookups]=\"lookups\"\n      (updateEmitter)=\"_onUpdate($event)\"\n      (getLookupsEmitter)=\"_onGetLookups($event)\"\n      (showModalEmitter)=\"_onShowModal($event)\"\n      (deleteEmitter)=\"_onDelete($event)\">\n    </lib-item-template-holder>\n  </div>\n</div>\n\n<div class=\"row\" *ngIf=\"!_dataCount || _dataCount === 0\">\n  <div class=\"col-12\">\n    <div class=\"row\">\n      <div class=\"col-12 no-results-container\">\n        <div class=\"text-center text-secondary\">\n          <span class=\"italic\">{{ emptyListDisplayText }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n`,\n  styles: [],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class NgEventstoreListingComponent\n  implements OnInit, OnChanges, OnDestroy {\n  @Output() updateEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() getLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() showModalEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() deleteEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() playbackListLoadedEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() newItemNotifyEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() removedItemNotifyEmitter: EventEmitter<any> = new EventEmitter();\n\n  @Input() itemComponentClass: any;\n  @Input() lookups = {};\n  @Input() socketUrl: string;\n  @Input() playbackListBaseUrl: string;\n  @Input() scriptStore: Script[];\n  @Input() itemSubscriptionConfigurations: SubscriptionConfiguration[] = [];\n  @Input() listSubscriptionConfiguration: SubscriptionConfiguration;\n  @Input() playbackListName: string;\n  @Input() filters: Filter[] = null;\n  @Input() sort: Sort[] = null;\n  @Input() pageIndex = 1;\n  @Input() itemsPerPage: number;\n  @Input() responseBasePath = 'data';\n  @Input() emptyListDisplayText = 'No Results';\n  @Input() csvFileName = '';\n\n  @Input() debugging = false;\n\n  _dataList: Immutable.List<RowItem>;\n  _dataCount: number;\n  _dataTotalCount: number;\n  _initialized = false;\n  _getPlaybackListSubscription: Subscription;\n  _getPlaybackListSubject: Subject<PlaybackListRequest> = new Subject();\n  _exportPlaybackListSubscription: Subscription;\n  _exportPlaybackListSubject: Subject<PlaybackListRequest> = new Subject();\n  _playbackSubscriptionTokens: string[] = [];\n  _playbackList: PlaybackList = {\n    get: (rowId: string, callback: (err, item) => void) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      if (rowIndex > -1) {\n        const data = this._dataList.get(rowIndex);\n        if (data) {\n          callback(null, (data as any).toJS());\n        } else {\n          callback(null, {});\n        }\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`), null);\n      }\n    },\n    add: (\n      rowId: string,\n      revision: number,\n      data: any,\n      meta: any,\n      callback: (err?: any) => void\n    ) => {\n      // const newEntry = {\n      //   rowId: rowId,\n      //   revision: revision,\n      //   data: data,\n      //   meta: meta,\n      // };\n      // this.dataList = this.dataList.push(Immutable.fromJS(newEntry));\n      // this.changeDetectorRef.detectChanges();\n      // Do refresh trigger\n      const newItem = {\n        rowId,\n        revision,\n        data,\n        meta\n      };\n      this.newItemNotifyEmitter.emit(newItem);\n      callback();\n    },\n    update: (\n      rowId: string,\n      revision: number,\n      oldData: any,\n      newData: any,\n      meta: any,\n      callback: (err?) => void\n    ) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      // oldData is Immutable\n      const newEntry = Immutable.fromJS({\n        rowId: rowId,\n        revision: revision,\n        data: {\n          ...oldData,\n          ...newData,\n        },\n        meta: meta,\n      });\n\n      if (this.debugging) {\n        console.log(newEntry);\n      }\n\n      if (rowIndex > -1) {\n        if (this.debugging) {\n          console.log(rowIndex);\n          console.log(newEntry);\n\n          console.log(this._dataList.toJS());\n        }\n        this._dataList = this._dataList.set(rowIndex, newEntry);\n\n        if (this.debugging) {\n          console.log(this._dataList.toJS());\n        }\n        this.changeDetectorRef.detectChanges();\n        callback();\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`));\n      }\n    },\n    delete: (rowId: string, callback: (error?: any) => void) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      if (rowIndex > -1) {\n        // this._dataList = this._dataList.remove(rowIndex);\n        this.removedItemNotifyEmitter.emit(rowId);\n        callback(null);\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`));\n      }\n    },\n  };\n\n  _stateFunctions = {\n    getState: (id: string) => {\n      const index = this._dataList.findIndex((row: any) => {\n        return row.get('rowId') === id;\n      });\n      if (index > 0) {\n        return (this._dataList.get(index) as any).toJS();\n      }\n\n      return {};\n    },\n    setState: (id: string, data: any) => {\n      const index = this._dataList.findIndex((row: any) => {\n        return row.get('rowId') === id;\n      });\n      this._dataList = this._dataList.set(index, Immutable.fromJS(data));\n      this.changeDetectorRef.markForCheck();\n    },\n  };\n\n  constructor(\n    private changeDetectorRef: ChangeDetectorRef,\n    private scriptService: ScriptService,\n    private playbackService: PlaybackService,\n    private playbackListService: PlaybackListService\n  ) {}\n\n  async ngOnInit() {\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const self = this;\n\n    if (!self._initialized) {\n      this._initialized = true;\n      this._loadScripts().then(() => {\n        this._initializeRequests();\n        this.playbackService.init(this.socketUrl);\n        const changesKeys = Object.keys(changes);\n        changesKeys.forEach((key) => {\n          self[key] = changes[key].currentValue;\n          switch (key) {\n            case 'pageIndex':\n            case 'filters':\n            case 'sort': {\n              this.requestPlaybackList();\n              break;\n            }\n          }\n        });\n\n      });\n    } else {\n      const changesKeys = Object.keys(changes);\n      changesKeys.forEach((key) => {\n        self[key] = changes[key].currentValue;\n        switch (key) {\n          case 'pageIndex':\n          case 'filters':\n          case 'sort':\n          case 'playbackListName': {\n            this.requestPlaybackList();\n            break;\n          }\n        }\n      });\n    }\n  }\n\n\n  ngOnDestroy() {\n    this._resetSubscriptions();\n    this._initialized = false;\n  }\n\n  trackByFn(index: number, item: any) {\n    return item.get('rowId');\n  }\n\n  private _initializeRequests(): void {\n    this._getPlaybackListSubscription = this._getPlaybackListSubject\n      .pipe(\n        debounceTime(100),\n        switchMap((params) => {\n          return this.playbackListService.getPlaybackList(\n            this.playbackListBaseUrl,\n            params.playbackListName,\n            params.startIndex,\n            params.limit,\n            params.filters,\n            params.sort\n          );\n        })\n      )\n      .subscribe((res: any) => {\n        this._dataList = Immutable.fromJS(res.rows);\n        this._dataCount = res.rows.length;\n        this._dataTotalCount = res.count;\n\n        this._resetSubscriptions();\n        this._initSubscriptions();\n\n        this.changeDetectorRef.detectChanges();\n\n        this.playbackListLoadedEmitter.emit({\n          totalItems: this._dataTotalCount,\n          dataCount: this._dataCount,\n        });\n      });\n\n    this._exportPlaybackListSubscription = this._exportPlaybackListSubject\n    .pipe(\n      debounceTime(100),\n      switchMap((params) => {\n        return this.playbackListService.getPlaybackListCsv(\n          this.playbackListBaseUrl,\n          params.playbackListName,\n          params.startIndex,\n          params.limit,\n          params.filters,\n          params.sort,\n          params.type\n        );\n      })\n    )\n    .subscribe((result: any) => {\n      const csv = new Blob([result], { type: 'text/csv' });\n      const moment = moment_;\n      const now = moment();\n      const fileName = `${now.format('YYYY_MM_DD_HH_mm_ss')}_${this.csvFileName || this.playbackListName}.csv`;\n      saveAs(csv, fileName);\n    });\n  }\n\n  _getPlaybackList(\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort[]\n  ) {\n    const playbackListRequestParams: PlaybackListRequest = {\n      playbackListName: playbackListName,\n      startIndex: startIndex,\n      limit: limit,\n      filters: filters,\n      sort: sort,\n    };\n    this._getPlaybackListSubject.next(playbackListRequestParams);\n  }\n\n  requestPlaybackList() {\n    const startIndex = this.itemsPerPage * (this.pageIndex - 1);\n    this._getPlaybackList(\n      this.playbackListName,\n      startIndex,\n      this.itemsPerPage,\n      this.filters,\n      this.sort\n    );\n  }\n\n  private async _loadScripts() {\n    if (this.scriptStore) {\n      await this.scriptService.init(this.scriptStore);\n    }\n  }\n\n  private async _initSubscriptions() {\n    const self = this;\n    // Per row subscriptions\n    (self.itemSubscriptionConfigurations || []).forEach((itemSubscriptionConfiguration: SubscriptionConfiguration) => {\n      if (itemSubscriptionConfiguration) {\n        self._dataList.forEach(async (row: any) => {\n          const streamRevisionFunction = itemSubscriptionConfiguration.streamRevisionFunction ?\n            itemSubscriptionConfiguration.streamRevisionFunction : () => +row.get('revision') + 1;\n\n          const aggregateId = itemSubscriptionConfiguration.rowIdFieldName ?\n              row.get('data').get(itemSubscriptionConfiguration.rowIdFieldName) : row.get('rowId');\n\n          const query: Query = _clone(itemSubscriptionConfiguration.query);\n          query.aggregateId = query.aggregateId.replace(\n            /{{rowId}}/g,\n            aggregateId\n          );\n\n          const playbackSubscriptionToken = await self.playbackService.registerForPlayback(\n            self,\n            itemSubscriptionConfiguration.playbackScriptName,\n            query,\n            self._stateFunctions,\n            self._playbackList,\n            streamRevisionFunction,\n            row.get('rowId'),\n            itemSubscriptionConfiguration.condition\n          );\n          this._playbackSubscriptionTokens.push(playbackSubscriptionToken);\n        });\n      }\n    });\n\n    if (self.listSubscriptionConfiguration) {\n      // List subscription\n      this._playbackSubscriptionTokens.push(\n        await self.playbackService.registerForPlayback(\n          self,\n          self.listSubscriptionConfiguration.playbackScriptName,\n          self.listSubscriptionConfiguration.query,\n          self._stateFunctions,\n          self._playbackList,\n          () => 0\n        )\n      );\n    }\n  }\n\n  _resetSubscriptions() {\n    this.playbackService.unregisterForPlayback(this._playbackSubscriptionTokens);\n    this._playbackSubscriptionTokens = [];\n  }\n\n  _onUpdate(payload: any) {\n    this.updateEmitter.emit(payload);\n  }\n\n  _onGetLookups(payload: any) {\n    this.getLookupsEmitter.emit(payload);\n  }\n\n  _onShowModal(payload: any) {\n    this.showModalEmitter.emit(payload);\n  }\n\n  _onDelete(payload: any) {\n    this.deleteEmitter.emit(payload);\n  }\n\n  exportCSV(overrideParams?: PlaybackListRequest) {\n    if (overrideParams) {\n      this._exportPlaybackListSubject.next(overrideParams);\n    } else {\n      const startIndex = this.itemsPerPage * (this.pageIndex - 1);\n      const exportPlaybackListRequestParams: PlaybackListRequest = {\n        playbackListName: this.playbackListName,\n        startIndex: startIndex,\n        limit: 1000000,\n        filters: this.filters,\n        sort: this.sort\n      };\n\n      this._exportPlaybackListSubject.next(exportPlaybackListRequestParams);\n    }\n  }\n}\n",
    "import { Directive, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[libTemplateDirective]'\n})\nexport class TemplateDirective {\n  constructor(public viewContainerRef: ViewContainerRef) { }\n}\n",
    "import {\n  Component,\n  OnInit,\n  Input,\n  ViewChild,\n  ComponentFactoryResolver,\n  Output,\n  EventEmitter,\n  OnChanges,\n  ComponentRef,\n  SimpleChanges,\n  ChangeDetectionStrategy,\n  AfterViewInit,\n} from '@angular/core';\nimport { ItemTemplateComponent } from '../template-components/index';\nimport { TemplateDirective } from '../../directives/template.directive';\n\n@Component({\n  selector: 'lib-item-template-holder',\n  template: `<div class=\"row no-gutters\">\n  <div class=\"col-12\">\n    <ng-template libTemplateDirective></ng-template>\n  </div>\n</div>\n`,\n  styles: [``],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ItemTemplateHolderComponent\n  implements OnInit, OnChanges, AfterViewInit {\n  @Input() itemComponentClass: any;\n  @Input() data: any = {};\n  @Input() lookups: any = {};\n  @Output() updateEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() getLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() showModalEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() deleteEmitter: EventEmitter<any> = new EventEmitter();\n\n  componentRef: ComponentRef<any>;\n  initialChanges: SimpleChanges;\n  @ViewChild(TemplateDirective) itemHost: TemplateDirective;\n\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}\n\n  ngOnInit(): void {\n    // this.loadComponent();\n  }\n\n  ngAfterViewInit(): void {\n    this.loadComponent();\n    if (this.initialChanges) {\n      this.ngOnChanges(this.initialChanges);\n      this.initialChanges = undefined;\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const self = this;\n    if (self.componentRef) {\n      const changesKeys = Object.keys(changes);\n      changesKeys.forEach((key) => {\n        (self.componentRef.instance as ItemTemplateComponent)[key] =\n          changes[key].currentValue;\n      });\n      (self.componentRef.instance as ItemTemplateComponent).ngOnChanges(\n        changes\n      );\n    } else {\n      this.initialChanges = changes;\n    }\n  }\n\n  loadComponent(): void {\n    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(\n      this.itemComponentClass\n    );\n    const viewContainerRef = this.itemHost.viewContainerRef;\n    viewContainerRef.clear();\n\n    this.componentRef = viewContainerRef.createComponent(componentFactory);\n    (this.componentRef.instance as ItemTemplateComponent).data = this.data;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onUpdateEmitter = this.updateEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onGetLookupsEmitter = this.getLookupsEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onShowModalEmitter = this.showModalEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onDeleteEmitter = this.deleteEmitter;\n    // (this.componentRef.instance as ItemTemplateComponent).idPropertyName = this.idPropertyName;\n    (this.componentRef\n      .instance as ItemTemplateComponent).lookups = this.lookups;\n    (this.componentRef.instance as ItemTemplateComponent).ngOnInit();\n  }\n}\n",
    "import { Injectable } from '@angular/core';\nimport * as io from 'socket.io-client';\n\n@Injectable()\nexport class SocketIoService {\n  // sockets = {};\n  constructor() { }\n  getSocketInstance(socketUrl) {\n    return io.connect(`${socketUrl}/events`);\n  //   if (!this.sockets[socketUrl]) {\n  //     this.sockets[socketUrl] = io.connect(`${socketUrl}/events`);\n  //   }\n  //   return this.sockets[socketUrl];\n  }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { NgEventstoreListingComponent } from './ng-eventstore-listing.component';\nimport { ItemTemplateHolderComponent } from './components/item-template-holder/item-template-holder.component';\n\nimport { CommonModule } from '@angular/common';\nimport { TemplateDirective } from './directives/template.directive';\n// import { IO_TOKEN, SocketIoService } from './services/socket.io.service';\n\n// import * as io from 'socket.io-client';\nimport { ScriptService } from './services/script.service';\nimport { PlaybackService } from './services/playback.service';\nimport { PlaybackListService } from './services/playback-list.service';\nimport { PushService } from './services/push.service';\nimport { SocketIoService } from './services/socket.io.service';\n\n@NgModule({\n  declarations: [\n    NgEventstoreListingComponent,\n    ItemTemplateHolderComponent,\n    TemplateDirective,\n\n  ],\n  imports: [CommonModule],\n  exports: [\n    NgEventstoreListingComponent\n  ],\n  providers: [\n    ScriptService,\n    PlaybackService,\n    PlaybackListService,\n    PushService,\n    SocketIoService\n    // ,\n    // { provide: IO_TOKEN, useValue: io }\n  ]\n})\nexport class NgEventstoreListingModule {}\n",
    "import {\n  EventEmitter,\n  OnInit,\n  OnChanges,\n  SimpleChanges,\n  ChangeDetectorRef,\n} from '@angular/core';\n\nimport {\n  FormGroup, Validators, FormControl\n} from '@angular/forms';\n\nexport abstract class ItemTemplateComponent implements OnInit, OnChanges {\n  // Event Emitters\n  onUpdateEmitter: EventEmitter<any> = new EventEmitter();\n  onGetLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  onShowModalEmitter: EventEmitter<any> = new EventEmitter();\n  onDeleteEmitter: EventEmitter<any> = new EventEmitter();\n\n  idPropertyName: string;\n  data: any; // Immutable item\n  lookups: any;\n  private _formGroup: FormGroup = new FormGroup({});\n  private _formGroupKeys: string[] = [];\n\n  _changeFn: (changes) => void;\n\n  constructor(protected changeDetectorRef?: ChangeDetectorRef) {}\n\n  ngOnInit(): void {}\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (this._changeFn) {\n      this._changeFn(changes);\n    }\n\n    const dataChanges = changes.data ? changes.data.currentValue : null;\n    if (dataChanges && !changes.data.isFirstChange()) {\n      const dataObj = (dataChanges as any).toJS();\n\n      this._formGroupKeys.forEach((key) => {\n        const newValue = dataObj.data[key];\n        const oldValue = this._formGroup.get(key).value;\n\n        if (newValue !== oldValue) {\n          this._formGroup.get(key).setValue(newValue, { emit: false, onlySelf: true });\n        }\n      });\n\n    }\n\n\n    if (this.changeDetectorRef) {\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n\n  registerChangeFunction = (changeFn: (changes) => void) => {\n    this._changeFn = changeFn;\n  }\n\n  onUpdate = (propertyName: string, actionData: any) => {\n    const actionEventEmitterData = {\n      propertyName: propertyName,\n      id: this.data.get(this.idPropertyName),\n      data: actionData,\n    };\n    this.onUpdateEmitter.emit(actionEventEmitterData);\n  }\n\n  onGetLookups = (lookupName: string, callback: (payload: any) => void) => {\n    const actionEventEmitterData = {\n      lookupName: lookupName,\n      callback: callback\n    };\n    this.onGetLookupsEmitter.emit(actionEventEmitterData);\n  }\n\n  onShowModal = (modalName, data) => {\n    const actionEventEmitterData = {\n      modalName: modalName,\n      id: this.data.get(this.idPropertyName),\n      data: data,\n    };\n    this.onShowModalEmitter.emit(actionEventEmitterData);\n  }\n\n  onDelete = (actionData?: any) => {\n    const actionEventEmitterData = {\n      id: this.data.get(this.idPropertyName),\n      data: actionData,\n    };\n    this.onDeleteEmitter.emit(actionEventEmitterData);\n  }\n\n  // registerFormControl(propertyName: string)\n  registerFormGroup = (formGroup: FormGroup): void => {\n    this._formGroup = formGroup;\n  }\n\n  createFormControl(propertyName: string, initialValue: any, validators: Validators): FormControl {\n    const formControl = new FormControl(initialValue, validators);\n    this._formGroup.addControl(propertyName, formControl);\n    this._formGroupKeys.push(propertyName);\n    return formControl;\n  }\n\n}\n",
    "export enum FilterOperator {\n  range = 'range',\n  is = 'is',\n  any = 'any',\n  contains = 'contains',\n  endsWith = 'endsWith',\n  startsWith = 'startsWith',\n  arrayContains = 'arrayContains',\n}\n",
    "export enum SortDirection {\n  ASC = 'ASC',\n  DESC = 'DESC',\n}\n",
    "export enum GroupBooleanOperator {\n  and = 'and',\n  or = 'or'\n}\n"
  ],
  "names": [
    "__awaiter",
    "thisArg",
    "_arguments",
    "P",
    "generator",
    "Promise",
    "resolve",
    "reject",
    "fulfilled",
    "value",
    "step",
    "next",
    "e",
    "rejected",
    "result",
    "done",
    "adopt",
    "then",
    "apply",
    "__generator",
    "body",
    "f",
    "y",
    "t",
    "g",
    "_",
    "label",
    "sent",
    "trys",
    "ops",
    "verb",
    "throw",
    "return",
    "Symbol",
    "iterator",
    "this",
    "n",
    "v",
    "op",
    "TypeError",
    "call",
    "pop",
    "length",
    "push",
    "ScriptService",
    "scripts",
    "prototype",
    "init",
    "scriptStore",
    "promises",
    "forEach",
    "script",
    "_this",
    "name",
    "loaded",
    "src",
    "meta",
    "load",
    "all",
    "_a",
    "_i",
    "arguments",
    "loadScript",
    "status",
    "document",
    "querySelectorAll",
    "script_1",
    "createElement",
    "type",
    "readyState",
    "onreadystatechange",
    "onload",
    "onerror",
    "error",
    "console",
    "log",
    "getElementsByTagName",
    "appendChild",
    "getScript",
    "scriptName",
    "Injectable",
    "Helpers",
    "Math",
    "random",
    "toString",
    "substr",
    "Date",
    "now",
    "PushService",
    "subscriptions",
    "socketUrl",
    "ioPush",
    "io.connect",
    "on",
    "eventObj",
    "_processEvent",
    "_forOwn",
    "sub",
    "subscriptionQuery",
    "Object",
    "assign",
    "query",
    "offset",
    "emit",
    "token",
    "self",
    "queryKey",
    "context",
    "aggregate",
    "aggregateId",
    "keys",
    "clientToken",
    "isNaN",
    "streamRevision",
    "cb",
    "undefined",
    "owner",
    "monitorTags",
    "tag",
    "_meta",
    "reason_1",
    "eventType",
    "stateType",
    "eventSource",
    "monitor",
    "callback",
    "subscribe",
    "pushToken",
    "subscriptionQuery_1",
    "subscriptionToken",
    "catchUpEvents",
    "event",
    "unsubscribe",
    "pushTokens",
    "socketTokens",
    "clientSubscription",
    "_clone",
    "PlaybackService",
    "scriptService",
    "pushService",
    "_playbackRegistry",
    "_conditionalSubscriptionRegistry",
    "unregisterForPlayback",
    "playbackTokens",
    "map",
    "playbackToken",
    "pushSubscriptionId",
    "tslib_1.__awaiter",
    "rowId",
    "registerForPlayback",
    "stateFunctions",
    "playbackList",
    "streamRevisionFunction",
    "conditionFunction",
    "item",
    "playbackSubscriptionId",
    "aggregateId_1",
    "get",
    "rowData",
    "isConditionTrue",
    "err",
    "owner2",
    "registration",
    "thisScriptName",
    "fromEvent",
    "payload",
    "eventName",
    "thisPlaybackScript",
    "window",
    "playbackFunction",
    "playbackInterface",
    "state",
    "targetQuery",
    "getPlaybackList",
    "playbackListName",
    "Error",
    "_updateConditionalSubscriptions",
    "row",
    "getState",
    "data",
    "Array",
    "isArray",
    "conditionalSubscription",
    "PlaybackListService",
    "http",
    "playbackListBaseUrl",
    "startIndex",
    "limit",
    "filters",
    "sort",
    "url",
    "JSON",
    "stringify",
    "getPlaybackListCsv",
    "HttpClient",
    "NgEventstoreListingComponent",
    "changeDetectorRef",
    "playbackService",
    "playbackListService",
    "updateEmitter",
    "EventEmitter",
    "getLookupsEmitter",
    "showModalEmitter",
    "deleteEmitter",
    "playbackListLoadedEmitter",
    "newItemNotifyEmitter",
    "removedItemNotifyEmitter",
    "lookups",
    "itemSubscriptionConfigurations",
    "pageIndex",
    "responseBasePath",
    "emptyListDisplayText",
    "csvFileName",
    "debugging",
    "_initialized",
    "_getPlaybackListSubject",
    "Subject",
    "_exportPlaybackListSubject",
    "_playbackSubscriptionTokens",
    "_playbackList",
    "rowIndex",
    "_dataList",
    "findIndex",
    "toJS",
    "add",
    "revision",
    "newItem",
    "update",
    "oldData",
    "newData",
    "newEntry",
    "Immutable.fromJS",
    "set",
    "detectChanges",
    "delete",
    "_stateFunctions",
    "id",
    "index",
    "setState",
    "markForCheck",
    "ngOnInit",
    "ngOnChanges",
    "changes",
    "key",
    "currentValue",
    "requestPlaybackList",
    "_loadScripts",
    "_initializeRequests",
    "ngOnDestroy",
    "_resetSubscriptions",
    "trackByFn",
    "_getPlaybackListSubscription",
    "pipe",
    "debounceTime",
    "switchMap",
    "params",
    "res",
    "rows",
    "_dataCount",
    "_dataTotalCount",
    "count",
    "_initSubscriptions",
    "totalItems",
    "dataCount",
    "_exportPlaybackListSubscription",
    "csv",
    "Blob",
    "fileName",
    "moment_",
    "format",
    "saveAs",
    "_getPlaybackList",
    "playbackListRequestParams",
    "itemsPerPage",
    "itemSubscriptionConfiguration",
    "rowIdFieldName",
    "replace",
    "playbackScriptName",
    "condition",
    "playbackSubscriptionToken",
    "listSubscriptionConfiguration",
    "_b",
    "_c",
    "_onUpdate",
    "_onGetLookups",
    "_onShowModal",
    "_onDelete",
    "exportCSV",
    "overrideParams",
    "exportPlaybackListRequestParams",
    "Component",
    "args",
    "selector",
    "template",
    "styles",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "ChangeDetectorRef",
    "Output",
    "itemComponentClass",
    "Input",
    "TemplateDirective",
    "viewContainerRef",
    "Directive",
    "ViewContainerRef",
    "ItemTemplateHolderComponent",
    "componentFactoryResolver",
    "ngAfterViewInit",
    "loadComponent",
    "initialChanges",
    "componentRef",
    "componentFactory",
    "resolveComponentFactory",
    "itemHost",
    "clear",
    "createComponent",
    "onUpdateEmitter",
    "onGetLookupsEmitter",
    "onShowModalEmitter",
    "onDeleteEmitter",
    "ComponentFactoryResolver",
    "ViewChild",
    "SocketIoService",
    "getSocketInstance",
    "NgEventstoreListingModule",
    "NgModule",
    "declarations",
    "imports",
    "CommonModule",
    "exports",
    "providers",
    "ItemTemplateComponent",
    "_formGroup",
    "FormGroup",
    "_formGroupKeys",
    "registerChangeFunction",
    "changeFn",
    "_changeFn",
    "onUpdate",
    "propertyName",
    "actionData",
    "actionEventEmitterData",
    "idPropertyName",
    "onGetLookups",
    "lookupName",
    "onShowModal",
    "modalName",
    "onDelete",
    "registerFormGroup",
    "formGroup",
    "dataChanges",
    "isFirstChange",
    "dataObj_1",
    "newValue",
    "setValue",
    "onlySelf",
    "createFormControl",
    "initialValue",
    "validators",
    "formControl",
    "FormControl",
    "addControl",
    "range",
    "is",
    "any",
    "contains",
    "endsWith",
    "startsWith",
    "arrayContains",
    "ASC",
    "DESC",
    "and",
    "or"
  ],
  "mappings": "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"
}
