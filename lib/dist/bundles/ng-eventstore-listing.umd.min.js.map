{
  "version": 3,
  "file": "ng-eventstore-listing.umd.min.js",
  "sources": [
    "ng://ng-eventstore-listing/node_modules/tslib/tslib.es6.js",
    "ng://ng-eventstore-listing/out/services/script.service.ts",
    "ng://ng-eventstore-listing/out/services/push.service.ts",
    "ng://ng-eventstore-listing/out/services/playback.service.ts",
    "ng://ng-eventstore-listing/out/services/playback-list.service.ts",
    "ng://ng-eventstore-listing/out/ng-eventstore-listing.component.ts",
    "ng://ng-eventstore-listing/out/directives/template.directive.ts",
    "ng://ng-eventstore-listing/out/components/item-template-holder/item-template-holder.component.ts",
    "ng://ng-eventstore-listing/out/services/socket.io.service.ts",
    "ng://ng-eventstore-listing/out/ng-eventstore-listing.module.ts",
    "ng://ng-eventstore-listing/out/components/template-components/item-template/item-template.component.ts",
    "ng://ng-eventstore-listing/out/enums/filter-operator.ts",
    "ng://ng-eventstore-listing/out/enums/sort-direction.ts",
    "ng://ng-eventstore-listing/out/enums/group-boolean-operator.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n",
    "import { Injectable } from '@angular/core';\nimport { Script } from '../models';\n\ndeclare var document: any;\n\n@Injectable()\nexport class ScriptService {\n  private scripts: any = {};\n\n  constructor() {}\n\n  async init(scriptStore: Script[]) {\n    const promises = [];\n    scriptStore.forEach((script: Script) => {\n      // console.log('SCRIPT STORE LOGGING');\n      this.scripts[script.name] = {\n        loaded: false,\n        src: script.src,\n        meta: script.meta,\n      };\n      promises.push(this.load(script.name));\n    });\n\n    return await Promise.all(promises);\n  }\n\n  async load(...scripts: string[]): Promise<any> {\n    const promises: any[] = [];\n    scripts.forEach((script) => promises.push(this.loadScript(script)));\n    return await Promise.all(promises);\n  }\n\n  loadScript(name: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // resolve if already loaded\n      if (this.scripts[name].loaded) {\n        // console.log('LOADED');\n        resolve({\n          script: name,\n          loaded: true,\n          status: 'Already Loaded',\n          meta: this.scripts[name].meta,\n        });\n      } else {\n        const existingScript = document.querySelectorAll(`head script[src=\"${this.scripts[name].src}\"]`);\n        if (existingScript.length === 0) {\n          // load script\n          const script = document.createElement('script');\n          script.type = 'text/javascript';\n          script.src = this.scripts[name].src;\n          if (script.readyState) {\n            // IE\n            script.onreadystatechange = () => {\n              // console.log('ON READYSTATECHANGE');\n              if (\n                script.readyState === 'loaded' ||\n                script.readyState === 'complete'\n              ) {\n                script.onreadystatechange = null;\n                this.scripts[name].loaded = true;\n                resolve({\n                  script: name,\n                  loaded: true,\n                  status: 'Loaded',\n                  meta: this.scripts[name].meta,\n                });\n              }\n            };\n          } else {\n            // Others\n            // console.log('ONLOAD');\n            script.onload = () => {\n              this.scripts[name].loaded = true;\n              resolve({\n                script: name,\n                loaded: true,\n                status: 'Loaded',\n                meta: this.scripts[name].meta,\n              });\n            };\n          }\n          script.onerror = (error: any) =>\n          console.log('ON ERROR', error);\n            resolve({\n              script: name,\n              loaded: false,\n              status: 'Loaded',\n              meta: this.scripts[name].meta,\n            });\n          document.getElementsByTagName('head')[0].appendChild(script);\n        } else {\n          // console.log('Script already exists');\n          resolve();\n        }\n      }\n    });\n  }\n\n  getScript(scriptName: string) {\n    return this.scripts[scriptName];\n  }\n}\n",
    "import { Injectable, Inject, NgZone } from '@angular/core';\nimport _forOwn from 'lodash-es/forOwn';\nimport _clone from 'lodash-es/clone';\nimport * as io from 'socket.io-client';\n\n// TODO: Make environment pluggable or derivable\n\n@Injectable()\nexport class PushService {\n  private ioPush: any;\n  private subscriptions: any = {};\n  constructor() { }\n\n  init(socketUrl: string) {\n    this.ioPush = io.connect(`${socketUrl}/events`);\n    const self = this;\n    this.ioPush.on('message', (eventObj, queryKey) => {\n      console.log('got message from push server: ', eventObj, queryKey);\n      const clientTokens = Object.keys(self.subscriptions);\n      // redirect to mapped subscription/token callback\n      clientTokens.forEach((clientToken) => {\n        const sub = self.subscriptions[clientToken];\n        if (sub) {\n          const subQueryKey = `${sub.query.context}.${sub.query.aggregate}.${sub.query.aggregateId}`;\n          if (subQueryKey === queryKey) {\n            // update next offset (from stream revision) for this subscription, so for reconnecting\n            if (!isNaN(eventObj.streamRevision)) {\n              sub.offset = eventObj.streamRevision + 1;\n            }\n            if (typeof sub.cb === 'function') {\n              sub.cb(undefined, eventObj, sub.owner, clientToken);\n            }\n\n            // iterate on monitors meta tags\n            const tags = Object.keys(sub.monitorTags);\n            tags.forEach((tag) => {\n              // check for state/eventSource._meta or event._meta\n              if (eventObj._meta && eventObj._meta.tag === tag) {\n                let reason = 'N/A';\n                if (typeof eventObj.eventType === 'string') {\n                  reason = eventObj.eventType;\n                } else if (typeof eventObj.stateType === 'string') {\n                  reason = eventObj.stateType;\n                  if (\n                    eventObj.eventSource &&\n                    typeof eventObj.eventSource.eventType === 'string'\n                  ) {\n                    reason += ` <- ${eventObj.eventSource.eventType}`;\n                  }\n                }\n                // iterate on the monitors\n                const monitors = sub.monitorTags[tag];\n                monitors.forEach((monitor) => {\n                  monitor.callback(reason, eventObj._meta);\n                });\n              }\n            });\n          }\n        }\n      });\n    });\n\n    this.ioPush.on('reconnect', () => {\n      // console.log('TEST RECONNECTION');\n      // this.ioPush.emit('resubscribe', () => {\n        // console.log(this.subscriptions);\n        _forOwn(this.subscriptions, (sub) => {\n          const subscriptionQuery = Object.assign(sub.query, {\n            offset: sub.offset,\n          });\n\n          this.ioPush.emit('subscribe', subscriptionQuery, (token: string) => {\n            if (token) {\n              // console.log('Reconnected:', token, subscriptionQuery);\n              sub.token = token;\n            } else {\n              console.error('Reconnect error for query', subscriptionQuery);\n            }\n          });\n        });\n      // });\n    });\n  }\n\n  subscribe(query, offset, owner, cb) {\n    // await this.waitForSocketConnection();\n    const clientToken =\n      Math.random().toString(36).substr(2, 9) + '-' + Date.now().toString();\n    // map new subscription, then try to subscribe to server asap\n    this.subscriptions[clientToken] = {\n      query: query,\n      offset: offset,\n      owner: owner,\n      cb: cb,\n      monitorTags: {},\n    };\n\n    const sub = this.subscriptions[clientToken];\n    if (sub && !sub.token) {\n      // build up proper subscribe request query\n      const subscriptionQuery = Object.assign(sub.query, {\n        offset: sub.offset,\n      });\n\n      this.ioPush.emit('subscribe', subscriptionQuery, (token: string) => {\n        if (token) {\n          // console.log('Server Subscribed:', token, subscriptionQuery);\n          sub.token = token;\n        } else {\n          console.error('Subscribe error for query', subscriptionQuery);\n        }\n      });\n    }\n\n\n    return clientToken;\n  }\n\n  unsubscribe(clientTokens): Promise<void> {\n    const socketTokens = [];\n\n    clientTokens.forEach((clientToken) => {\n      if (this.subscriptions[clientToken]) {\n        const clientSubscription = _clone(this.subscriptions[clientToken]);\n        delete this.subscriptions[clientToken];\n\n        const sub = clientSubscription;\n        if (sub && sub.token) {\n          socketTokens.push(sub.token);\n        }\n      }\n    });\n\n    return new Promise((resolve, reject) => {\n      this.ioPush.emit('unsubscribe', socketTokens, () => {\n        resolve();\n      });\n    });\n  }\n}\n",
    "import { Injectable } from '@angular/core';\nimport { ScriptService } from './script.service';\nimport { PushService } from './push.service';\nimport {\n  StateFunctions,\n  PlaybackList,\n  PlaybackRegistry,\n  Query,\n  ConditionalSubscriptionRegistry,\n} from '../models';\n\n@Injectable()\nexport class PlaybackService {\n  private playbackRegistry: PlaybackRegistry = {};\n  private conditionalSubscriptionRegistry: ConditionalSubscriptionRegistry = {};\n\n  constructor(\n    private scriptService: ScriptService,\n    private pushService: PushService\n  ) {}\n\n  init(socketUrl: string) {\n    this.pushService.init(socketUrl);\n  }\n\n  async unRegisterForPlayback(tokens: string[]) {\n    // unsubscribe from push\n    await this.pushService.unsubscribe(tokens);\n\n    // unregister from playback registry\n    tokens.forEach((token) => {\n      delete this.playbackRegistry[token];\n    });\n  }\n\n  async registerForPlayback(\n    owner: object,\n    scriptName: string,\n    query: Query,\n    stateFunctions: StateFunctions,\n    playbackList: PlaybackList,\n    streamRevisionFunction: (item: any) => number = (item) => { return 0 },\n    rowId?: string,\n    conditionFunction?: (item: any) => boolean\n  ) {\n    const playbackSubscriptionId = Math.random().toString(36).substr(2, 9) + '-' + Date.now().toString();\n\n    const script = await this.scriptService.getScript(scriptName);\n    let playbackScript;\n    if (script) {\n      playbackScript = window[script.meta.objectName];\n    }\n\n    let rowData;\n    if (rowId) {\n      const aggregateId = rowId ? rowId : query.aggregateId;\n      rowData = await new Promise((resolve, reject) => {\n        playbackList.get(aggregateId, (error, item) => {\n          if (error) {\n            reject(error);\n          }\n          resolve(item);\n        });\n      });\n    }\n\n    const streamRevision = streamRevisionFunction(rowData);\n\n    // Check if condition is true\n    const isConditionTrue = conditionFunction ? conditionFunction(rowData) : undefined;\n\n    let pushSubscriptionId\n    if (isConditionTrue === true || conditionFunction === undefined) {\n      pushSubscriptionId = await this.pushService.subscribe(\n        query,\n        streamRevision,\n        this,\n        async (err, eventObj, owner2) => {\n          // owner is playbackservice\n          const self = owner2 as PlaybackService;\n          console.log(self.playbackRegistry);\n          console.log(playbackSubscriptionId);\n          const registration = self.playbackRegistry[playbackSubscriptionId];\n\n          if (eventObj.aggregate === 'states') {\n            const thisScriptName = registration.scriptName;\n            const fromEvent = eventObj.payload._meta.fromEvent;\n            const eventName = fromEvent.payload.name;\n            const thisPlaybackScript = window[thisScriptName];\n            const playbackFunction = thisPlaybackScript.playbackInterface[eventName];\n\n            if (playbackFunction) {\n              if (registration.rowId) {\n                eventObj.aggregateId = registration.rowId;\n              }\n              const state = eventObj.payload;\n              const funcs = {\n                emit: (targetQuery, payload, done) => {\n                  done();\n                },\n                getPlaybackList: (\n                  playbackListName: string,\n                  callback: (err, playbackList: PlaybackList) => void\n                ) => {\n                  if (registration.playbackList) {\n                    callback(null, registration.playbackList);\n                  } else {\n                    callback(\n                      new Error(\n                        'PlaybackList does not exist in this registration'\n                      ),\n                      null\n                    );\n                  }\n                },\n              };\n\n              const doneCallback = () => {\n                registration.playbackList.get(eventObj.aggregateId, (error, item) => {\n                  self._updateConditionalSubscriptions(eventObj.aggregateId, item);\n                });\n              };\n\n              playbackFunction(state, fromEvent, funcs, doneCallback);\n            }\n          } else {\n\n            const thisScriptName = registration.scriptName;\n            const thisPlaybackScript = window[thisScriptName];\n            const playbackFunction = thisPlaybackScript.playbackInterface[eventObj.payload.name];\n\n            if (playbackFunction) {\n              // Override aggregateId to handle other subscriptions\n              if (registration.rowId) {\n                eventObj.aggregateId = registration.rowId;\n              }\n              const row = stateFunctions.getState(eventObj.aggregateId);\n              const state = row.data;\n              const funcs = {\n                emit: (targetQuery, payload, done) => {\n                  done();\n                },\n                getPlaybackList: (\n                  playbackListName: string,\n                  callback: (err, playbackList: PlaybackList) => void\n                ) => {\n                  if (registration.playbackList) {\n                    callback(null, registration.playbackList);\n                  } else {\n                    callback(\n                      new Error(\n                        'PlaybackList does not exist in this registration'\n                      ),\n                      null\n                    );\n                  }\n                },\n              };\n\n              const doneCallback = () => {\n                registration.playbackList.get(eventObj.aggregateId, (error, item) => {\n                  self._updateConditionalSubscriptions(eventObj.aggregateId, item);\n                });\n              };\n\n              playbackFunction(state, eventObj, funcs, doneCallback);\n            }\n          }\n        }\n      );\n    }\n\n    // If condition exists, register in conditional registry\n    if (conditionFunction) {\n      if (this.conditionalSubscriptionRegistry[rowId] && Array.isArray(this.conditionalSubscriptionRegistry[rowId])) {\n        this.conditionalSubscriptionRegistry[rowId].push({\n          playbackList: playbackList,\n          playbackScript: playbackScript,\n          scriptName: scriptName,\n          owner: owner,\n          stateFunctions: stateFunctions,\n          query: query,\n          streamRevisionFunction: streamRevisionFunction,\n          conditionFunction: conditionFunction,\n          subscriptionToken: pushSubscriptionId\n        });\n      } else {\n        this.conditionalSubscriptionRegistry[rowId] = [{\n          playbackList: playbackList,\n          playbackScript: playbackScript,\n          scriptName: scriptName,\n          owner: owner,\n          stateFunctions: stateFunctions,\n          query: query,\n          streamRevisionFunction: streamRevisionFunction,\n          conditionFunction: conditionFunction,\n          subscriptionToken: pushSubscriptionId\n        }];\n      }\n    }\n\n\n    this.playbackRegistry[playbackSubscriptionId] = {\n      playbackScript: playbackScript,\n      owner: owner,\n      registrationId: pushSubscriptionId,\n      playbackList: playbackList,\n      scriptName: scriptName,\n      rowId: rowId\n    };\n\n\n\n    console.log('subscribed to playback: ', playbackSubscriptionId, pushSubscriptionId, query);\n    return playbackSubscriptionId;\n  }\n\n  async registerConditionalSubscriptions(\n    conditionFunction: (item) => boolean,\n    scriptName: string,\n    owner: object,\n    query: Query,\n    stateFunctions: StateFunctions,\n    playbackList: PlaybackList,\n    rowId?: string,\n    streamRevisionFunction?: (item) =>  number,\n    subscriptionToken?: string\n  ) {\n    const script = await this.scriptService.getScript(scriptName);\n    let playbackScript;\n    if (script) {\n      playbackScript = window[script.meta.objectName];\n    }\n\n\n    if (this.conditionalSubscriptionRegistry[rowId] && Array.isArray(this.conditionalSubscriptionRegistry[rowId])) {\n      this.conditionalSubscriptionRegistry[rowId].push({\n        playbackList: playbackList,\n        playbackScript: playbackScript,\n        scriptName: scriptName,\n        owner: owner,\n        stateFunctions: stateFunctions,\n        query: query,\n        streamRevisionFunction: streamRevisionFunction,\n        conditionFunction: conditionFunction,\n        subscriptionToken: subscriptionToken\n      });\n    } else {\n      this.conditionalSubscriptionRegistry[rowId] = [{\n        playbackList: playbackList,\n        playbackScript: playbackScript,\n        scriptName: scriptName,\n        owner: owner,\n        stateFunctions: stateFunctions,\n        query: query,\n        streamRevisionFunction: streamRevisionFunction,\n        conditionFunction: conditionFunction,\n        subscriptionToken: subscriptionToken\n      }];\n    }\n  }\n\n  _updateConditionalSubscriptions(rowId, rowData) {\n    const conditionalSubscriptions = this.conditionalSubscriptionRegistry[rowId] || [];\n    conditionalSubscriptions.forEach(async (conditionalSubscription) => {\n      if (!conditionalSubscription.subscriptionToken && conditionalSubscription.conditionFunction(rowData)) {\n        const offset = conditionalSubscription.streamRevisionFunction(rowData);\n        const subscriptionId = this.pushService.subscribe(\n          conditionalSubscription.query,\n          offset,\n          this,\n          async (err, eventObj, owner2, token) => {\n            // owner is playbackservice\n            const self = owner2 as PlaybackService;\n            const registration = self.playbackRegistry[token];\n\n            if (eventObj.aggregate === 'states') {\n              const thisScriptName = registration.scriptName;\n              const fromEvent = eventObj.payload._meta.fromEvent;\n              const eventName = fromEvent.payload.name;\n              const thisPlaybackScript = window[thisScriptName];\n              const playbackFunction = thisPlaybackScript.playbackInterface[eventName];\n\n              if (playbackFunction) {\n                const state = eventObj.payload;\n                const funcs = {\n                  emit: (targetQuery, payload, done) => {\n                    done();\n                  },\n                  getPlaybackList: (\n                    playbackListName: string,\n                    callback: (err, playbackList: PlaybackList) => void\n                  ) => {\n                    if (registration.playbackList) {\n                      callback(null, registration.playbackList);\n                    } else {\n                      callback(\n                        new Error(\n                          'PlaybackList does not exist in this registration'\n                        ),\n                        null\n                      );\n                    }\n                  },\n                };\n\n                const doneCallback = () => {\n                };\n                playbackFunction(state, fromEvent, funcs, doneCallback);\n              }\n            } else {\n\n              const thisScriptName = registration.scriptName;\n              const thisPlaybackScript = window[thisScriptName];\n              const playbackFunction = thisPlaybackScript.playbackInterface[eventObj.payload.name];\n\n              if (playbackFunction) {\n                // Override aggregateId to handle other subscriptions\n                if (registration.rowId) {\n                  eventObj.aggregateId = registration.rowId;\n                }\n                const row = conditionalSubscription.stateFunctions.getState(eventObj.aggregateId);\n                const state = row.data;\n                const funcs = {\n                  emit: (targetQuery, payload, done) => {\n                    done();\n                  },\n                  getPlaybackList: (\n                    playbackListName: string,\n                    callback: (err, playbackList: PlaybackList) => void\n                  ) => {\n                    if (registration.playbackList) {\n                      callback(null, registration.playbackList);\n                    } else {\n                      callback(\n                        new Error(\n                          'PlaybackList does not exist in this registration'\n                        ),\n                        null\n                      );\n                    }\n                  },\n                };\n\n                const doneCallback = () => {\n                  // stateFunctions.setState(row.rowId, row);\n                };\n\n                playbackFunction(state, eventObj, funcs, doneCallback);\n              }\n            }\n          }\n        );\n\n        // just use the subscriptionId to map the push subscription to the playback\n        this.playbackRegistry[subscriptionId] = {\n          playbackScript: conditionalSubscription.playbackScript,\n          owner: conditionalSubscription.owner,\n          registrationId: subscriptionId,\n          playbackList: conditionalSubscription.playbackList,\n          scriptName: conditionalSubscription.scriptName,\n          rowId: rowId\n        };\n\n        conditionalSubscription.subscriptionToken = subscriptionId;\n\n        console.log('subscribed to playback: ', subscriptionId, conditionalSubscription.query);\n        return subscriptionId;\n      } else if (!conditionalSubscription.conditionFunction(rowData) && conditionalSubscription.subscriptionToken) {\n        this.pushService.unsubscribe([conditionalSubscription.subscriptionToken]).then(() => {\n          delete this.playbackRegistry[conditionalSubscription.subscriptionToken];\n          conditionalSubscription.subscriptionToken = undefined;\n        });\n      }\n    });\n  }\n\n}\n",
    "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs/Observable';\nimport { Filter, Sort, PlaybackListResponse } from '../models';\n\n@Injectable()\nexport class PlaybackListService {\n  constructor(private http: HttpClient) {}\n\n  getPlaybackList(\n    playbackListBaseUrl: string,\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort[]\n  ): Observable<PlaybackListResponse> {\n    let url = `${playbackListBaseUrl}/playback-list/${playbackListName}?startIndex=${startIndex}&limit=${limit}`;\n\n    if (filters) {\n      url += `&filters=${JSON.stringify(filters)}`;\n    }\n\n    if (sort) {\n      url += `&sort=${JSON.stringify(sort)}`;\n    }\n\n    return this.http.get<PlaybackListResponse>(url);\n  }\n\n  getPlaybackListCsv(\n    playbackListBaseUrl: string,\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort[],\n    type?: string\n  ): Observable<any> {\n    let url = `${playbackListBaseUrl}/playback-list/${playbackListName}/export?startIndex=${startIndex}&limit=${limit}`;\n\n    if (filters) {\n      url += `&filters=${JSON.stringify(filters)}`;\n    }\n\n    if (sort) {\n      url += `&sort=${JSON.stringify(sort)}`;\n    }\n\n    if (type) {\n      url += `&type=${type}`;\n    }\n\n    return this.http.get<PlaybackListResponse>(url);\n  }\n}\n",
    "import {\n  Component,\n  OnInit,\n  Input,\n  Output,\n  EventEmitter,\n  OnChanges,\n  SimpleChanges,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  OnDestroy,\n} from '@angular/core';\n\nimport { switchMap, debounceTime } from 'rxjs/operators';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Subject } from 'rxjs/Subject';\n\nimport {\n  SubscriptionConfiguration,\n  Script,\n  PlaybackList,\n  RowItem,\n  Filter,\n  Query,\n  Sort,\n  PlaybackListRequest,\n} from './models';\n\n\nimport { ScriptService } from './services/script.service';\nimport { PlaybackService } from './services/playback.service';\nimport { PlaybackListService } from './services/playback-list.service';\n\nimport * as Immutable from 'immutable';\nimport _defaultsDeep from 'lodash-es/defaultsDeep';\nimport _isEmpty from 'lodash-es/isEmpty';\nimport _isEqual from 'lodash-es/isEqual';\nimport _cloneDeep from 'lodash-es/cloneDeep';\nimport _clone from 'lodash-es/clone';\nimport _uniq from 'lodash-es/uniq';\nimport _merge from 'lodash-es/defaults';\nimport * as moment_ from 'moment-mini-ts';\n\nimport saveAs from 'file-saver';\n\n@Component({\n  selector: 'lib-ng-eventstore-listing',\n  template: `<!-- <div *ngIf=\"listHeaderGroups && listHeaderGroups.groups && listHeaderGroups.groups.length > 0\"  [class]=\"'row ' + (listHeaderGroups && listHeaderGroups.generalRowClassName ? listHeaderGroups.generalRowClassName : '')\">\n  <div class=\"col-12\">\n    <div class=\"header bg-white p-2\">\n      <div [class]=\"'row ' + listHeaderGroups.generalRowClassName\">\n        <div *ngFor=\"let listHeaderGroup of listHeaderGroups.groups\" [class]=\"listHeaderGroup.className\">\n          <div [class]=\"'row ' + listHeaderGroups.generalRowClassName\">\n            <div *ngFor=\"let listHeader of listHeaderGroup.listHeaders\" [class]=\"listHeader.className\">\n              <span (click)=\"onSort(listHeader.sortProperty)\" [ngClass]=\"{ 'sort-header': listHeader.sortProperty }\">{{ listHeader.displayName }} <i *ngIf=\"sortFields[listHeader.sortProperty] && sortFields[listHeader.sortProperty].icon\" [class]=\"'sort-icon ' + sortFields[listHeader.sortProperty].icon\"></i></span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div> -->\n<!-- <div [class]=\"'row ' + (listHeaderGroups && listHeaderGroups.generalRowClassName) ? listHeaderGroups.generalRowClassName : ''\" *ngFor=\"let item of dataList; trackBy: trackByFn\"> -->\n<div class=\"row\" *ngFor=\"let item of _dataList; trackBy: trackByFn\">\n  <div class=\"col-12\">\n    <lib-item-template-holder\n      [data]=\"item\"\n      [itemComponentClass]=\"itemComponentClass\"\n      [lookups]=\"lookups\"\n      (updateEmitter)=\"_onUpdate($event)\"\n      (updateLookupsEmitter)=\"_onUpdateLookups($event)\"\n      (showModalEmitter)=\"_onShowModal($event)\"\n      (deleteEmitter)=\"_onDelete($event)\">\n    </lib-item-template-holder>\n  </div>\n</div>\n\n<div class=\"row\" *ngIf=\"!_dataCount || _dataCount === 0\">\n  <div class=\"col-12\">\n    <div class=\"row\">\n      <div class=\"col-12 no-results-container\">\n        <div class=\"text-center text-secondary\">\n          <span class=\"italic\">{{ emptyListDisplayText }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n`,\n  styles: [],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class NgEventstoreListingComponent\n  implements OnInit, OnChanges, OnDestroy {\n  @Output() updateEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() updateLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() showModalEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() deleteEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() playbackListLoadedEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() newItemNotifyEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() removedItemNotifyEmitter: EventEmitter<any> = new EventEmitter();\n\n  @Input() itemComponentClass: any;\n  @Input() lookups = {};\n  @Input() socketUrl: string;\n  @Input() playbackListBaseUrl: string;\n  @Input() scriptStore: Script[];\n  @Input() itemSubscriptionConfigurations: SubscriptionConfiguration[] = [];\n  @Input() listSubscriptionConfiguration: SubscriptionConfiguration;\n  @Input() playbackListName: string;\n  @Input() filters: Filter[] = null;\n  @Input() sort: Sort[] = null;\n  @Input() pageIndex = 1;\n  @Input() itemsPerPage: number;\n  @Input() responseBasePath = 'data';\n  @Input() emptyListDisplayText = 'No Results';\n  @Input() csvFileName = '';\n\n  @Input() debugging = false;\n\n  _dataList: Immutable.List<RowItem>;\n  _dataCount: number;\n  _dataTotalCount: number;\n  _initialized = false;\n  _getPlaybackListSubscription: Subscription;\n  _getPlaybackListSubject: Subject<PlaybackListRequest> = new Subject();\n  _exportPlaybackListSubscription: Subscription;\n  _exportPlaybackListSubject: Subject<PlaybackListRequest> = new Subject();\n  _playbackSubscriptionTokens: string[] = [];\n  _playbackList: PlaybackList = {\n    get: (rowId: string, callback: (err, item) => void) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      if (rowIndex > -1) {\n        const data = this._dataList.get(rowIndex);\n        if (data) {\n          callback(null, (data as any).toJS());\n        } else {\n          callback(null, {});\n        }\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`), null);\n      }\n    },\n    add: (\n      rowId: string,\n      revision: number,\n      data: any,\n      meta: any,\n      callback: (err?: any) => void\n    ) => {\n      // const newEntry = {\n      //   rowId: rowId,\n      //   revision: revision,\n      //   data: data,\n      //   meta: meta,\n      // };\n      // this.dataList = this.dataList.push(Immutable.fromJS(newEntry));\n      // this.changeDetectorRef.detectChanges();\n      // Do refresh trigger\n      const newItem = {\n        rowId,\n        revision,\n        data,\n        meta\n      };\n      this.newItemNotifyEmitter.emit(newItem);\n      callback();\n    },\n    update: (\n      rowId: string,\n      revision: number,\n      oldData: any,\n      newData: any,\n      meta: any,\n      callback: (err?) => void\n    ) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      // oldData is Immutable\n      const newEntry = Immutable.fromJS({\n        rowId: rowId,\n        revision: revision,\n        data: {\n          ...oldData,\n          ...newData,\n        },\n        meta: meta,\n      });\n\n      if (this.debugging) {\n        console.log(newEntry);\n      }\n\n      if (rowIndex > -1) {\n        if (this.debugging) {\n          console.log(rowIndex);\n          console.log(newEntry);\n\n          console.log(this._dataList.toJS());\n        }\n        this._dataList = this._dataList.set(rowIndex, newEntry);\n\n        if (this.debugging) {\n          console.log(this._dataList.toJS());\n        }\n        this.changeDetectorRef.detectChanges();\n        callback();\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`));\n      }\n    },\n    delete: (rowId: string, callback: (error?: any) => void) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      if (rowIndex > -1) {\n        // this._dataList = this._dataList.remove(rowIndex);\n        this.removedItemNotifyEmitter.emit(rowId);\n        callback(null);\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`));\n      }\n    },\n  };\n\n  _stateFunctions = {\n    getState: (id: string) => {\n      const index = this._dataList.findIndex((row: any) => {\n        return row.get('rowId') === id;\n      });\n      if (index > 0) {\n        return (this._dataList.get(index) as any).toJS();\n      }\n\n      return {};\n    },\n    setState: (id: string, data: any) => {\n      const index = this._dataList.findIndex((row: any) => {\n        return row.get('rowId') === id;\n      });\n      this._dataList = this._dataList.set(index, Immutable.fromJS(data));\n      this.changeDetectorRef.markForCheck();\n    },\n  };\n\n  constructor(\n    private changeDetectorRef: ChangeDetectorRef,\n    private scriptService: ScriptService,\n    private playbackService: PlaybackService,\n    private playbackListService: PlaybackListService\n  ) {}\n\n  async ngOnInit() {\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const self = this;\n\n    if (!self._initialized) {\n      this._initialized = true;\n      this._loadScripts().then(() => {\n        this._initializeRequests();\n        this.playbackService.init(this.socketUrl);\n        const changesKeys = Object.keys(changes);\n        changesKeys.forEach((key) => {\n          self[key] = changes[key].currentValue;\n          switch (key) {\n            case 'pageIndex':\n            case 'filters':\n            case 'sort': {\n              this.requestPlaybackList();\n              break;\n            }\n          }\n        });\n\n      });\n    } else {\n      console.log(changes);\n      const changesKeys = Object.keys(changes);\n      changesKeys.forEach((key) => {\n        self[key] = changes[key].currentValue;\n        switch (key) {\n          case 'pageIndex':\n          case 'filters':\n          case 'sort':\n          case 'playbackListName': {\n            this.requestPlaybackList();\n            break;\n          }\n        }\n      });\n    }\n  }\n\n\n  ngOnDestroy() {\n    this._resetSubscriptions();\n    this._initialized = false;\n  }\n\n  trackByFn(index: number, item: any) {\n    return item.get('rowId');\n  }\n\n  private _initializeRequests(): void {\n    this._getPlaybackListSubscription = this._getPlaybackListSubject\n      .pipe(\n        debounceTime(100),\n        switchMap((params) => {\n          return this.playbackListService.getPlaybackList(\n            this.playbackListBaseUrl,\n            params.playbackListName,\n            params.startIndex,\n            params.limit,\n            params.filters,\n            params.sort\n          );\n        })\n      )\n      .subscribe((res: any) => {\n        this._dataList = Immutable.fromJS(res.rows);\n        this._dataCount = res.rows.length;\n        this._dataTotalCount = res.count;\n\n        this._resetSubscriptions();\n        this._initSubscriptions();\n\n        this.changeDetectorRef.detectChanges();\n\n        this.playbackListLoadedEmitter.emit({\n          totalItems: this._dataTotalCount,\n          dataCount: this._dataCount,\n        });\n      });\n\n    this._exportPlaybackListSubscription = this._exportPlaybackListSubject\n    .pipe(\n      debounceTime(100),\n      switchMap((params) => {\n        return this.playbackListService.getPlaybackListCsv(\n          this.playbackListBaseUrl,\n          params.playbackListName,\n          params.startIndex,\n          params.limit,\n          params.filters,\n          params.sort,\n          params.type\n        );\n      })\n    )\n    .subscribe((result: any) => {\n      const csv = new Blob([result], { type: 'text/csv' });\n      const moment = moment_;\n      const now = moment();\n      const fileName = `${now.format('YYYY_MM_DD_HH_mm_ss')}_${this.csvFileName || this.playbackListName}.csv`;\n      saveAs(csv, fileName);\n    });\n  }\n\n  _getPlaybackList(\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort[]\n  ) {\n    const playbackListRequestParams: PlaybackListRequest = {\n      playbackListName: playbackListName,\n      startIndex: startIndex,\n      limit: limit,\n      filters: filters,\n      sort: sort,\n    };\n    this._getPlaybackListSubject.next(playbackListRequestParams);\n  }\n\n  requestPlaybackList() {\n    const startIndex = this.itemsPerPage * (this.pageIndex - 1);\n    this._getPlaybackList(\n      this.playbackListName,\n      startIndex,\n      this.itemsPerPage,\n      this.filters,\n      this.sort\n    );\n  }\n\n  private async _loadScripts() {\n    if (this.scriptStore) {\n      await this.scriptService.init(this.scriptStore);\n    }\n  }\n\n  private async _initSubscriptions() {\n    const self = this;\n    // Per row subscriptions\n    (self.itemSubscriptionConfigurations || []).forEach((itemSubscriptionConfiguration: SubscriptionConfiguration) => {\n      if (itemSubscriptionConfiguration) {\n        self._dataList.forEach(async (row: any) => {\n          const streamRevisionFunction = itemSubscriptionConfiguration.streamRevisionFunction;\n\n          const aggregateId = itemSubscriptionConfiguration.rowIdFieldName ?\n              row.get('data').get(itemSubscriptionConfiguration.rowIdFieldName) : row.get('rowId');\n\n          const query: Query = _clone(itemSubscriptionConfiguration.query);\n          query.aggregateId = query.aggregateId.replace(\n            /{{rowId}}/g,\n            aggregateId\n          );\n\n          const playbackSubscriptionToken = await self.playbackService.registerForPlayback(\n            self,\n            itemSubscriptionConfiguration.playbackScriptName,\n            query,\n            self._stateFunctions,\n            self._playbackList,\n            streamRevisionFunction,\n            row.get('rowId'),\n            itemSubscriptionConfiguration.condition\n          );\n          this._playbackSubscriptionTokens.push(playbackSubscriptionToken);\n        });\n      }\n    });\n\n    if (self.listSubscriptionConfiguration) {\n      // List subscription\n      this._playbackSubscriptionTokens.push(\n        await self.playbackService.registerForPlayback(\n          self,\n          self.listSubscriptionConfiguration.playbackScriptName,\n          self.listSubscriptionConfiguration.query,\n          self._stateFunctions,\n          self._playbackList,\n          () => { return 0 }\n        )\n      );\n    }\n  }\n\n  _resetSubscriptions() {\n    this.playbackService.unRegisterForPlayback(this._playbackSubscriptionTokens);\n    this._playbackSubscriptionTokens = [];\n  }\n\n  _onUpdate(payload: any) {\n    this.updateEmitter.emit(payload);\n  }\n\n  _onUpdateLookups(payload: any) {\n    this.updateLookupsEmitter.emit(payload);\n  }\n\n  _onShowModal(payload: any) {\n    this.showModalEmitter.emit(payload);\n  }\n\n  _onDelete(payload: any) {\n    this.deleteEmitter.emit(payload);\n  }\n\n  exportCSV(overrideParams?: PlaybackListRequest) {\n    if (overrideParams) {\n      this._exportPlaybackListSubject.next(overrideParams);\n    } else {\n      const startIndex = this.itemsPerPage * (this.pageIndex - 1);\n      const exportPlaybackListRequestParams: PlaybackListRequest = {\n        playbackListName: this.playbackListName,\n        startIndex: startIndex,\n        limit: 1000000,\n        filters: this.filters,\n        sort: this.sort\n      };\n\n      this._exportPlaybackListSubject.next(exportPlaybackListRequestParams);\n    }\n  }\n}\n",
    "import { Directive, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[libTemplateDirective]'\n})\nexport class TemplateDirective {\n  constructor(public viewContainerRef: ViewContainerRef) { }\n}\n",
    "import {\n  Component,\n  OnInit,\n  Input,\n  ViewChild,\n  ComponentFactoryResolver,\n  Output,\n  EventEmitter,\n  OnChanges,\n  ComponentRef,\n  SimpleChanges,\n  ChangeDetectionStrategy,\n  AfterViewInit,\n} from '@angular/core';\nimport { ItemTemplateComponent } from '../template-components/index';\nimport { TemplateDirective } from '../../directives/template.directive';\n\n@Component({\n  selector: 'lib-item-template-holder',\n  template: `<div class=\"row no-gutters\">\n  <div class=\"col-12\">\n    <ng-template libTemplateDirective></ng-template>\n  </div>\n</div>\n`,\n  styles: [``],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ItemTemplateHolderComponent\n  implements OnInit, OnChanges, AfterViewInit {\n  @Input() itemComponentClass: any;\n  @Input() data: any = {};\n  @Input() lookups: any = {};\n  @Output() updateEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() updateLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() showModalEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() deleteEmitter: EventEmitter<any> = new EventEmitter();\n\n  componentRef: ComponentRef<any>;\n  initialChanges: SimpleChanges;\n  @ViewChild(TemplateDirective) itemHost: TemplateDirective;\n\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}\n\n  ngOnInit(): void {\n    // this.loadComponent();\n  }\n\n  ngAfterViewInit(): void {\n    this.loadComponent();\n    if (this.initialChanges) {\n      this.ngOnChanges(this.initialChanges);\n      this.initialChanges = undefined;\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const self = this;\n    if (self.componentRef) {\n      const changesKeys = Object.keys(changes);\n      changesKeys.forEach((key) => {\n        (self.componentRef.instance as ItemTemplateComponent)[key] =\n          changes[key].currentValue;\n      });\n      (self.componentRef.instance as ItemTemplateComponent).ngOnChanges(\n        changes\n      );\n    } else {\n      this.initialChanges = changes;\n    }\n  }\n\n  loadComponent(): void {\n    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(\n      this.itemComponentClass\n    );\n    const viewContainerRef = this.itemHost.viewContainerRef;\n    viewContainerRef.clear();\n\n    this.componentRef = viewContainerRef.createComponent(componentFactory);\n    (this.componentRef.instance as ItemTemplateComponent).data = this.data;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onUpdateEmitter = this.updateEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onUpdateLookupsEmitter = this.updateLookupsEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onShowModalEmitter = this.showModalEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onDeleteEmitter = this.deleteEmitter;\n    // (this.componentRef.instance as ItemTemplateComponent).idPropertyName = this.idPropertyName;\n    (this.componentRef\n      .instance as ItemTemplateComponent).lookups = this.lookups;\n    (this.componentRef.instance as ItemTemplateComponent).ngOnInit();\n  }\n}\n",
    "import { Injectable } from '@angular/core';\nimport * as io from 'socket.io-client';\n\n@Injectable()\nexport class SocketIoService {\n  // sockets = {};\n  constructor() { }\n  getSocketInstance(socketUrl) {\n    return io.connect(`${socketUrl}/events`);\n  //   if (!this.sockets[socketUrl]) {\n  //     this.sockets[socketUrl] = io.connect(`${socketUrl}/events`);\n  //   }\n  //   return this.sockets[socketUrl];\n  }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { NgEventstoreListingComponent } from './ng-eventstore-listing.component';\nimport { ItemTemplateHolderComponent } from './components/item-template-holder/item-template-holder.component';\n\nimport { CommonModule } from '@angular/common';\nimport { TemplateDirective } from './directives/template.directive';\n// import { IO_TOKEN, SocketIoService } from './services/socket.io.service';\n\n// import * as io from 'socket.io-client';\nimport { ScriptService } from './services/script.service';\nimport { PlaybackService } from './services/playback.service';\nimport { PlaybackListService } from './services/playback-list.service';\nimport { PushService } from './services/push.service';\nimport { SocketIoService } from './services/socket.io.service';\n\n@NgModule({\n  declarations: [\n    NgEventstoreListingComponent,\n    ItemTemplateHolderComponent,\n    TemplateDirective,\n\n  ],\n  imports: [CommonModule],\n  exports: [\n    NgEventstoreListingComponent\n  ],\n  providers: [\n    ScriptService,\n    PlaybackService,\n    PlaybackListService,\n    PushService,\n    SocketIoService\n    // ,\n    // { provide: IO_TOKEN, useValue: io }\n  ]\n})\nexport class NgEventstoreListingModule {}\n",
    "import {\n  EventEmitter,\n  OnInit,\n  OnChanges,\n  SimpleChanges,\n  ChangeDetectorRef,\n} from '@angular/core';\n\nimport {\n  FormGroup, Validators, FormControl\n} from '@angular/forms';\n\nexport abstract class ItemTemplateComponent implements OnInit, OnChanges {\n  // Event Emitters\n  onUpdateEmitter: EventEmitter<any> = new EventEmitter();\n  onUpdateLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  onShowModalEmitter: EventEmitter<any> = new EventEmitter();\n  onDeleteEmitter: EventEmitter<any> = new EventEmitter();\n\n  idPropertyName: string;\n  data: any; // Immutable item\n  lookups: any;\n  private _formGroup: FormGroup = new FormGroup({});\n  private _formGroupKeys: string[] = [];\n\n  _changeFn: (changes) => void;\n\n  constructor(protected changeDetectorRef?: ChangeDetectorRef) {}\n\n  ngOnInit(): void {}\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (this._changeFn) {\n      this._changeFn(changes);\n    }\n\n    const dataChanges = changes.data ? changes.data.currentValue : null;\n    if (dataChanges && !changes.data.isFirstChange()) {\n      const dataObj = (dataChanges as any).toJS();\n\n      this._formGroupKeys.forEach((key) => {\n        const newValue = dataObj.data[key];\n        const oldValue = this._formGroup.get(key).value;\n\n        if (newValue !== oldValue) {\n          this._formGroup.get(key).setValue(newValue, { emit: false, onlySelf: true });\n        }\n      });\n\n    }\n\n\n    if (this.changeDetectorRef) {\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n\n  registerChangeFunction = (changeFn: (changes) => void) => {\n    this._changeFn = changeFn;\n  }\n\n  onUpdate = (propertyName: string, actionData: any) => {\n    const actionEventEmitterData = {\n      propertyName: propertyName,\n      id: this.data.get(this.idPropertyName),\n      data: actionData,\n    };\n    this.onUpdateEmitter.emit(actionEventEmitterData);\n  }\n\n  onUpdateLookups = (lookup) => {\n    const actionEventEmitterData = {\n      lookup: lookup,\n    };\n    this.onUpdateLookupsEmitter.emit(actionEventEmitterData);\n  }\n\n  onShowModal = (modalName, data) => {\n    const actionEventEmitterData = {\n      modalName: modalName,\n      id: this.data.get(this.idPropertyName),\n      data: data,\n    };\n    this.onShowModalEmitter.emit(actionEventEmitterData);\n  }\n\n  onDelete = (actionData?: any) => {\n    const actionEventEmitterData = {\n      id: this.data.get(this.idPropertyName),\n      data: actionData,\n    };\n    this.onDeleteEmitter.emit(actionEventEmitterData);\n  }\n\n  // registerFormControl(propertyName: string)\n  registerFormGroup = (formGroup: FormGroup): void => {\n    this._formGroup = formGroup;\n  }\n\n  createFormControl(propertyName: string, initialValue: any, validators: Validators): FormControl {\n    const formControl = new FormControl(initialValue, validators);\n    this._formGroup.addControl(propertyName, formControl);\n    this._formGroupKeys.push(propertyName);\n    return formControl;\n  }\n\n}\n",
    "export enum FilterOperator {\n  range = 'range',\n  is = 'is',\n  any = 'any',\n  contains = 'contains',\n  endsWith = 'endsWith',\n  startsWith = 'startsWith',\n  arrayContains = 'arrayContains',\n}\n",
    "export enum SortDirection {\n  ASC = 'ASC',\n  DESC = 'DESC',\n}\n",
    "export enum GroupBooleanOperator {\n  and = 'and',\n  or = 'or'\n}\n"
  ],
  "names": [
    "__awaiter",
    "thisArg",
    "_arguments",
    "P",
    "generator",
    "Promise",
    "resolve",
    "reject",
    "fulfilled",
    "value",
    "step",
    "next",
    "e",
    "rejected",
    "result",
    "done",
    "adopt",
    "then",
    "apply",
    "__generator",
    "body",
    "f",
    "y",
    "t",
    "g",
    "_",
    "label",
    "sent",
    "trys",
    "ops",
    "verb",
    "throw",
    "return",
    "Symbol",
    "iterator",
    "this",
    "n",
    "v",
    "op",
    "TypeError",
    "call",
    "pop",
    "length",
    "push",
    "ScriptService",
    "scripts",
    "prototype",
    "init",
    "scriptStore",
    "promises",
    "forEach",
    "script",
    "_this",
    "name",
    "loaded",
    "src",
    "meta",
    "load",
    "all",
    "_a",
    "_i",
    "arguments",
    "loadScript",
    "status",
    "document",
    "querySelectorAll",
    "script_1",
    "createElement",
    "type",
    "readyState",
    "onreadystatechange",
    "onload",
    "onerror",
    "error",
    "console",
    "log",
    "getElementsByTagName",
    "appendChild",
    "getScript",
    "scriptName",
    "Injectable",
    "PushService",
    "subscriptions",
    "socketUrl",
    "ioPush",
    "io.connect",
    "self",
    "on",
    "eventObj",
    "queryKey",
    "Object",
    "keys",
    "clientToken",
    "sub",
    "query",
    "context",
    "aggregate",
    "aggregateId",
    "isNaN",
    "streamRevision",
    "offset",
    "cb",
    "undefined",
    "owner",
    "monitorTags",
    "tag",
    "_meta",
    "reason_1",
    "eventType",
    "stateType",
    "eventSource",
    "monitor",
    "callback",
    "_forOwn",
    "subscriptionQuery",
    "assign",
    "emit",
    "token",
    "subscribe",
    "Math",
    "random",
    "toString",
    "substr",
    "Date",
    "now",
    "subscriptionQuery_1",
    "unsubscribe",
    "clientTokens",
    "socketTokens",
    "clientSubscription",
    "_clone",
    "PlaybackService",
    "scriptService",
    "pushService",
    "playbackRegistry",
    "conditionalSubscriptionRegistry",
    "unRegisterForPlayback",
    "tokens",
    "registerForPlayback",
    "stateFunctions",
    "playbackList",
    "streamRevisionFunction",
    "rowId",
    "conditionFunction",
    "item",
    "playbackSubscriptionId",
    "playbackScript",
    "window",
    "objectName",
    "aggregateId_1",
    "get",
    "rowData",
    "err",
    "owner2",
    "tslib_1.__awaiter",
    "registration",
    "thisScriptName",
    "fromEvent",
    "payload",
    "eventName",
    "thisPlaybackScript",
    "playbackFunction",
    "playbackInterface",
    "state",
    "targetQuery",
    "getPlaybackList",
    "playbackListName",
    "Error",
    "_updateConditionalSubscriptions",
    "row",
    "getState",
    "data",
    "pushSubscriptionId",
    "Array",
    "isArray",
    "subscriptionToken",
    "registrationId",
    "registerConditionalSubscriptions",
    "conditionalSubscription",
    "subscriptionId",
    "PlaybackListService",
    "http",
    "playbackListBaseUrl",
    "startIndex",
    "limit",
    "filters",
    "sort",
    "url",
    "JSON",
    "stringify",
    "getPlaybackListCsv",
    "HttpClient",
    "NgEventstoreListingComponent",
    "changeDetectorRef",
    "playbackService",
    "playbackListService",
    "updateEmitter",
    "EventEmitter",
    "updateLookupsEmitter",
    "showModalEmitter",
    "deleteEmitter",
    "playbackListLoadedEmitter",
    "newItemNotifyEmitter",
    "removedItemNotifyEmitter",
    "lookups",
    "itemSubscriptionConfigurations",
    "pageIndex",
    "responseBasePath",
    "emptyListDisplayText",
    "csvFileName",
    "debugging",
    "_initialized",
    "_getPlaybackListSubject",
    "Subject",
    "_exportPlaybackListSubject",
    "_playbackSubscriptionTokens",
    "_playbackList",
    "rowIndex",
    "_dataList",
    "findIndex",
    "toJS",
    "add",
    "revision",
    "newItem",
    "update",
    "oldData",
    "newData",
    "newEntry",
    "Immutable.fromJS",
    "set",
    "detectChanges",
    "delete",
    "_stateFunctions",
    "id",
    "index",
    "setState",
    "markForCheck",
    "ngOnInit",
    "ngOnChanges",
    "changes",
    "key",
    "currentValue",
    "requestPlaybackList",
    "_loadScripts",
    "_initializeRequests",
    "ngOnDestroy",
    "_resetSubscriptions",
    "trackByFn",
    "_getPlaybackListSubscription",
    "pipe",
    "debounceTime",
    "switchMap",
    "params",
    "res",
    "rows",
    "_dataCount",
    "_dataTotalCount",
    "count",
    "_initSubscriptions",
    "totalItems",
    "dataCount",
    "_exportPlaybackListSubscription",
    "csv",
    "Blob",
    "fileName",
    "moment_",
    "format",
    "saveAs",
    "_getPlaybackList",
    "playbackListRequestParams",
    "itemsPerPage",
    "itemSubscriptionConfiguration",
    "rowIdFieldName",
    "replace",
    "playbackScriptName",
    "condition",
    "playbackSubscriptionToken",
    "listSubscriptionConfiguration",
    "_b",
    "_c",
    "_onUpdate",
    "_onUpdateLookups",
    "_onShowModal",
    "_onDelete",
    "exportCSV",
    "overrideParams",
    "exportPlaybackListRequestParams",
    "Component",
    "args",
    "selector",
    "template",
    "styles",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "ChangeDetectorRef",
    "Output",
    "itemComponentClass",
    "Input",
    "TemplateDirective",
    "viewContainerRef",
    "Directive",
    "ViewContainerRef",
    "ItemTemplateHolderComponent",
    "componentFactoryResolver",
    "ngAfterViewInit",
    "loadComponent",
    "initialChanges",
    "componentRef",
    "componentFactory",
    "resolveComponentFactory",
    "itemHost",
    "clear",
    "createComponent",
    "onUpdateEmitter",
    "onUpdateLookupsEmitter",
    "onShowModalEmitter",
    "onDeleteEmitter",
    "ComponentFactoryResolver",
    "ViewChild",
    "SocketIoService",
    "getSocketInstance",
    "NgEventstoreListingModule",
    "NgModule",
    "declarations",
    "imports",
    "CommonModule",
    "exports",
    "providers",
    "ItemTemplateComponent",
    "_formGroup",
    "FormGroup",
    "_formGroupKeys",
    "registerChangeFunction",
    "changeFn",
    "_changeFn",
    "onUpdate",
    "propertyName",
    "actionData",
    "actionEventEmitterData",
    "idPropertyName",
    "onUpdateLookups",
    "lookup",
    "onShowModal",
    "modalName",
    "onDelete",
    "registerFormGroup",
    "formGroup",
    "dataChanges",
    "isFirstChange",
    "dataObj_1",
    "newValue",
    "setValue",
    "onlySelf",
    "createFormControl",
    "initialValue",
    "validators",
    "formControl",
    "FormControl",
    "addControl",
    "range",
    "is",
    "any",
    "contains",
    "endsWith",
    "startsWith",
    "arrayContains",
    "ASC",
    "DESC",
    "and",
    "or"
  ],
  "mappings": "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"
}
