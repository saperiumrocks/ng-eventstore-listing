{
  "version": 3,
  "file": "ng-eventstore-listing.umd.min.js",
  "sources": [
    "ng://ng-eventstore-listing/node_modules/tslib/tslib.es6.js",
    "ng://ng-eventstore-listing/out/services/script.service.ts",
    "ng://ng-eventstore-listing/out/services/socket.io.service.ts",
    "ng://ng-eventstore-listing/out/services/push.service.ts",
    "ng://ng-eventstore-listing/out/services/playback.service.ts",
    "ng://ng-eventstore-listing/out/services/playback-list.service.ts",
    "ng://ng-eventstore-listing/out/ng-eventstore-listing.component.ts",
    "ng://ng-eventstore-listing/out/directives/template.directive.ts",
    "ng://ng-eventstore-listing/out/components/item-template-holder/item-template-holder.component.ts",
    "ng://ng-eventstore-listing/out/ng-eventstore-listing.module.ts",
    "ng://ng-eventstore-listing/out/components/template-components/item-template/item-template.component.ts",
    "ng://ng-eventstore-listing/out/enums/filter-operator.ts",
    "ng://ng-eventstore-listing/out/enums/sort-direction.ts",
    "ng://ng-eventstore-listing/out/enums/group-boolean-operator.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n",
    "import { Injectable } from '@angular/core';\nimport { Script } from '../models';\n\ndeclare var document: any;\n\n@Injectable()\nexport class ScriptService {\n  private scripts: any = {};\n\n  constructor() {}\n\n  async init(scriptStore: Script[]) {\n    const promises = [];\n    scriptStore.forEach((script: Script) => {\n      // console.log('SCRIPT STORE LOGGING');\n      this.scripts[script.name] = {\n        loaded: false,\n        src: script.src,\n        meta: script.meta,\n      };\n      promises.push(this.load(script.name));\n    });\n\n    return await Promise.all(promises);\n  }\n\n  async load(...scripts: string[]): Promise<any> {\n    const promises: any[] = [];\n    scripts.forEach((script) => promises.push(this.loadScript(script)));\n    return await Promise.all(promises);\n  }\n\n  loadScript(name: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // resolve if already loaded\n      if (this.scripts[name].loaded) {\n        console.log('LOADED');\n        resolve({\n          script: name,\n          loaded: true,\n          status: 'Already Loaded',\n          meta: this.scripts[name].meta,\n        });\n      } else {\n        const existingScript = document.querySelectorAll(`head script[src=\"${this.scripts[name].src}\"]`);\n        if (existingScript.length === 0) {\n          // load script\n          const script = document.createElement('script');\n          script.type = 'text/javascript';\n          script.src = this.scripts[name].src;\n          if (script.readyState) {\n            // IE\n            script.onreadystatechange = () => {\n              console.log('ON READYSTATECHANGE');\n              if (\n                script.readyState === 'loaded' ||\n                script.readyState === 'complete'\n              ) {\n                script.onreadystatechange = null;\n                this.scripts[name].loaded = true;\n                resolve({\n                  script: name,\n                  loaded: true,\n                  status: 'Loaded',\n                  meta: this.scripts[name].meta,\n                });\n              }\n            };\n          } else {\n            // Others\n            console.log('ONLOAD');\n            script.onload = () => {\n              this.scripts[name].loaded = true;\n              resolve({\n                script: name,\n                loaded: true,\n                status: 'Loaded',\n                meta: this.scripts[name].meta,\n              });\n            };\n          }\n          script.onerror = (error: any) =>\n          console.log('ON ERROR', error);;\n            resolve({\n              script: name,\n              loaded: false,\n              status: 'Loaded',\n              meta: this.scripts[name].meta,\n            });\n          document.getElementsByTagName('head')[0].appendChild(script);\n        }\n      }\n    });\n  }\n\n  getScript(scriptName: string) {\n    return this.scripts[scriptName];\n  }\n}\n",
    "import { InjectionToken } from '@angular/core';\n\nexport let IO_TOKEN = new InjectionToken<any>('io');\n",
    "import { Injectable, Inject, NgZone } from '@angular/core';\nimport { IO_TOKEN } from './socket.io.service';\n\n// TODO: Make environment pluggable or derivable\n\n@Injectable()\nexport class PushService {\n  private ioPush: any;\n  private subscriptions: any = {};\n  constructor(@Inject(IO_TOKEN) private io: any, private ngZone: NgZone) {}\n\n  init(socketUrl: string) {\n    this.ioPush = this.io(`${socketUrl}/events`);\n\n    const self = this;\n    this.ioPush.on('message', (eventObj, token) => {\n      console.log('got message from push server: ', eventObj, token);\n      const clientTokens = Object.keys(self.subscriptions);\n      // redirect to mapped subscription/token callback\n      clientTokens.forEach((clientToken) => {\n        const sub = self.subscriptions[clientToken];\n        if (sub.token === token) {\n          // update next offset (from stream revision) for this subscription, so for reconnecting\n          if (!isNaN(eventObj.streamRevision)) {\n            sub.offset = eventObj.streamRevision + 1;\n          }\n          if (typeof sub.cb === 'function') {\n            sub.cb(undefined, eventObj, sub.owner, clientToken);\n          }\n\n          // iterate on monitors meta tags\n          const tags = Object.keys(sub.monitorTags);\n          tags.forEach((tag) => {\n            // check for state/eventSource._meta or event._meta\n            if (eventObj._meta && eventObj._meta.tag === tag) {\n              let reason = 'N/A';\n              if (typeof eventObj.eventType === 'string') {\n                reason = eventObj.eventType;\n              } else if (typeof eventObj.stateType === 'string') {\n                reason = eventObj.stateType;\n                if (\n                  eventObj.eventSource &&\n                  typeof eventObj.eventSource.eventType === 'string'\n                ) {\n                  reason += ` <- ${eventObj.eventSource.eventType}`;\n                }\n              }\n              // iterate on the monitors\n              const monitors = sub.monitorTags[tag];\n              monitors.forEach((monitor) => {\n                monitor.callback(reason, eventObj._meta);\n              });\n            }\n          });\n        }\n      });\n    });\n  }\n\n  async subscribe(query, offset, owner, cb) {\n    // await this.waitForSocketConnection();\n    const clientToken =\n      Math.random().toString(36).substr(2, 9) + '-' + Date.now().toString();\n    // map new subscription, then try to subscribe to server asap\n    this.subscriptions[clientToken] = {\n      query: query,\n      offset: offset,\n      owner: owner,\n      cb: cb,\n      monitorTags: {},\n    };\n\n    const sub = this.subscriptions[clientToken];\n    if (sub && !sub.token) {\n      // build up proper subscribe request query\n      const subscriptionQuery = Object.assign(sub.query, {\n        offset: sub.offset,\n      });\n\n      this.ioPush.emit('subscribe', subscriptionQuery, (token: string) => {\n        if (token) {\n          console.log('Server Subscribed:', token, subscriptionQuery);\n          sub.token = token;\n        } else {\n          console.error('Subscribe error for query', subscriptionQuery);\n        }\n      });\n    }\n\n\n    return clientToken;\n  }\n\n  // async subscribeStreams() {\n  //   // await this.waitForSocketConnection();\n  //   if (this.ioPush.connected) {\n  //     // this.ioPush.on('connected', () => {\n  //     console.log(this.subscriptions);\n  //     const clientTokens = Object.keys(this.subscriptions);\n  //     clientTokens.forEach((clientToken) => {\n  //       const sub = this.subscriptions[clientToken];\n  //       // do server subsribe for those without tokens yet\n  //       if (!sub.token) {\n  //         // build up proper subscribe request query\n  //         const query = Object.assign(sub.query, {\n  //           offset: sub.offset,\n  //         });\n  //         console.log('SUBSCRIBE IS CALLED:', query);\n  //         this.ioPush.emit('subscribe', query, (token: string) => {\n  //           console.log('SUBSCRIBE EMIT');\n  //           if (token) {\n  //             console.log('Server Subscribed:', token, query);\n  //             sub.token = token;\n  //           } else {\n  //             console.error('Subscribe error for query', query);\n  //           }\n  //         });\n  //       }\n  //     });\n  //     // })\n  //   }\n  // }\n\n  unsubscribe(clientToken): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        // just do a force server unsubscribe and removal of subscription entry\n        const sub = this.subscriptions[clientToken];\n        if (sub) {\n          if (sub.token && this.ioPush.connected) {\n            //  NOTE: need to handle unsubscribe/emit errors\n            this.ioPush.emit('unsubscribe', sub.token, () => {\n                resolve();\n            });\n          }\n          delete this.subscriptions[clientToken];\n          resolve();\n          // console.log('Unsubscribed:', clientToken, subscriptions);\n        }\n        // no subscription\n        resolve();\n      } catch (error) {\n        reject(error);\n        console.error('error in unsubscribing: ', error);\n      }\n    });\n  }\n\n  // async waitForSocketConnection(): Promise<any> {\n  //   return new Promise((resolve, reject) => {\n  //     let timeout;\n  //     this.ngZone.runOutsideAngular(() => {\n  //       timeout = setTimeout(() => {\n  //         this.ngZone.run(() => {\n  //           console.error('IO Connectioned timedout');\n  //           reject();\n  //         });\n  //       }, 10000)\n  //     })\n\n\n  //     while(!this.ioPush.connected) {\n  //       console.log(this.ioPush);\n  //     }\n  //     clearTimeout(timeout);\n  //     return resolve();\n\n  //   })\n  // }\n\n  // monitorMeta(clientToken, tag, timeout, cb) {\n  //   const self = this;\n  //   const sub = self.subscriptions[clientToken];\n  //   if (sub && typeof tag === 'string' && typeof cb === 'function') {\n  //     const monitorToken =\n  //       Math.random().toString(36).substr(2, 9) + '-' + Date.now().toString();\n  //     // setup monitor token/filter/callback mapping\n  //     if (!sub.monitorTags[tag]) { sub.monitorTags[tag] = []; }\n  //     sub.monitorTags[tag].push({\n  //       token: monitorToken,\n  //       callback: cb,\n  //     });\n  //     setTimeout(() => {\n  //       const sub = self.subscriptions[clientToken];\n  //       if (sub && Array.isArray(sub.monitorTags[tag])) {\n  //         const idx = sub.monitorTags[tag].findIndex(\n  //           (x) => x.token === monitorToken\n  //         );\n  //         if (idx != -1) { sub.monitorTags[tag].splice(idx, 1); }\n  //         if (sub.monitorTags[tag].length <= 0) { delete sub.monitorTags[tag]; }\n  //         // console.log('TAGS:', clientToken, sub.monitorTags);\n  //       }\n  //     }, timeout);\n  //   }\n  // }\n}\n",
    "import { Injectable } from '@angular/core';\nimport { ScriptService } from './script.service';\nimport { PushService } from './push.service';\nimport {\n  StateFunctions,\n  PlaybackList,\n  PlaybackRegistry,\n  Query,\n} from '../models';\n\n@Injectable()\nexport class PlaybackService {\n  private playbackRegistry: PlaybackRegistry = {};\n  private playbackInterfaceMap = {};\n  constructor(\n    private scriptService: ScriptService,\n    private pushService: PushService\n  ) {}\n\n  init(socketUrl: string) {\n    this.pushService.init(socketUrl);\n  }\n\n  async unRegisterForPlayback(token) {\n    // unsubscribe from push\n    await this.pushService.unsubscribe(token);\n\n    // unregister from playback registry\n    delete this.playbackRegistry[token];\n  }\n\n  async registerForPlayback(\n    scriptName: string,\n    owner: object,\n    query: Query,\n    stateFunctions: StateFunctions,\n    offset?: number,\n    playbackList?: PlaybackList\n  ) {\n    const script = await this.scriptService.getScript(scriptName);\n    const playbackScript = window[script.meta.objectName];\n    const subscriptionId = await this.pushService.subscribe(\n      query,\n      offset,\n      this,\n      (err, eventObj, owner2, token) => {\n        // owner is playbackservice\n        const self = owner2 as PlaybackService;\n        const registration = self.playbackRegistry[token];\n        // call the function\n        // const playbackList = self.createPlaybacklist(registration)\n\n        // if (typeof eventObj.stateType !== 'undefined' && eventObj.eventSource)\n        //   eventObj = eventObj.eventSource;\n\n        if (eventObj.context === 'states') {\n          const scriptName = registration.scriptName;\n          const fromEvent = eventObj.payload._meta.fromEvent;\n          const eventName = fromEvent.payload.name\n          const playbackScript = window[scriptName];\n          const playbackFunction = playbackScript.playbackInterface[eventName];\n\n          if (playbackFunction) {\n            const row = stateFunctions.getState(eventObj.aggregateId);\n            const state = row.data;\n            const funcs = {\n              emit: (targetQuery, payload, done) => {\n                done();\n              },\n              getPlaybackList: (\n                playbackListName: string,\n                callback: (err, playbackList: PlaybackList) => void\n              ) => {\n                if (registration.playbackList) {\n                  callback(null, registration.playbackList);\n                } else {\n                  callback(\n                    new Error(\n                      'PlaybackList does not exist in this registration'\n                    ),\n                    null\n                  );\n                }\n              },\n            };\n\n            const doneCallback = () => {\n              // stateFunctions.setState(row.rowId, row);\n            };\n\n            playbackFunction(state, fromEvent, funcs, doneCallback);\n          }\n        } else {\n          const scriptName = registration.scriptName;\n          // const playbackFunction =\n          //   registration.playbackScript.playbackInterface[\n          //     eventObj.payload.name\n          //   ];\n          const playbackScript = window[scriptName];\n          const playbackFunction = playbackScript.playbackInterface[eventObj.payload.name];\n\n          if (playbackFunction) {\n            const row = stateFunctions.getState(eventObj.aggregateId);\n            const state = row.data;\n            const funcs = {\n              emit: (targetQuery, payload, done) => {\n                done();\n              },\n              getPlaybackList: (\n                playbackListName: string,\n                callback: (err, playbackList: PlaybackList) => void\n              ) => {\n                if (registration.playbackList) {\n                  callback(null, registration.playbackList);\n                } else {\n                  callback(\n                    new Error(\n                      'PlaybackList does not exist in this registration'\n                    ),\n                    null\n                  );\n                }\n              },\n            };\n\n            const doneCallback = () => {\n              // stateFunctions.setState(row.rowId, row);\n            };\n\n            playbackFunction(state, eventObj, funcs, doneCallback);\n          }\n        }\n      }\n    );\n\n    // just use the subscriptionId to map the push subscription to the playback\n    this.playbackRegistry[subscriptionId] = {\n      playbackScript: playbackScript,\n      owner: owner,\n      registrationId: subscriptionId,\n      playbackList: playbackList,\n      scriptName: scriptName\n    };\n\n    console.log('SHOW PLAYBACK SCRIPT');\n    console.log(playbackScript)\n\n    console.log('subscribed to playback: ', subscriptionId, query);\n    return subscriptionId;\n  }\n}\n",
    "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs/Observable';\nimport { Filter, Sort, PlaybackListResponse } from '../models';\n\n@Injectable()\nexport class PlaybackListService {\n  constructor(private http: HttpClient) {}\n\n  getPlaybackList(\n    playbackListBaseUrl: string,\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort\n  ): Observable<PlaybackListResponse> {\n    let url = `${playbackListBaseUrl}/playback-list/${playbackListName}?startIndex=${startIndex}&limit=${limit}`;\n\n    if (filters) {\n      url += `&filters=${JSON.stringify(filters)}`;\n    }\n\n    if (sort) {\n      url += `&sort=${JSON.stringify(sort)}`;\n    }\n\n    return this.http.get<PlaybackListResponse>(url);\n  }\n\n  getPlaybackListCsv(\n    playbackListBaseUrl: string,\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort\n  ): Observable<any> {\n    let url = `${playbackListBaseUrl}/playback-list/${playbackListName}/export?startIndex=${startIndex}&limit=${limit}`;\n\n    if (filters) {\n      url += `&filters=${JSON.stringify(filters)}`;\n    }\n\n    if (sort) {\n      url += `&sort=${JSON.stringify(sort)}`;\n    }\n\n    return this.http.get<PlaybackListResponse>(url);\n  }\n}\n",
    "import {\n  Component,\n  OnInit,\n  Input,\n  Output,\n  EventEmitter,\n  OnChanges,\n  SimpleChanges,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  OnDestroy,\n} from '@angular/core';\n\nimport { switchMap, debounceTime } from 'rxjs/operators';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Subject } from 'rxjs/Subject';\n\nimport {\n  SubscriptionConfiguration,\n  Script,\n  PlaybackList,\n  RowItem,\n  Filter,\n  Query,\n  Sort,\n  PlaybackListRequest,\n} from './models';\n\n\nimport { ScriptService } from './services/script.service';\nimport { PlaybackService } from './services/playback.service';\nimport { PlaybackListService } from './services/playback-list.service';\n\nimport * as Immutable from 'immutable';\nimport _defaultsDeep from 'lodash-es/defaultsDeep';\nimport _isEmpty from 'lodash-es/isEmpty';\nimport _isEqual from 'lodash-es/isEqual';\nimport _cloneDeep from 'lodash-es/cloneDeep';\nimport _clone from 'lodash-es/clone';\nimport _uniq from 'lodash-es/uniq';\nimport _merge from 'lodash-es/defaults';\nimport * as moment_ from 'moment-mini-ts';\n\nimport saveAs from 'file-saver';\n\n@Component({\n  selector: 'lib-ng-eventstore-listing',\n  template: `<!-- <div *ngIf=\"listHeaderGroups && listHeaderGroups.groups && listHeaderGroups.groups.length > 0\"  [class]=\"'row ' + (listHeaderGroups && listHeaderGroups.generalRowClassName ? listHeaderGroups.generalRowClassName : '')\">\n  <div class=\"col-12\">\n    <div class=\"header bg-white p-2\">\n      <div [class]=\"'row ' + listHeaderGroups.generalRowClassName\">\n        <div *ngFor=\"let listHeaderGroup of listHeaderGroups.groups\" [class]=\"listHeaderGroup.className\">\n          <div [class]=\"'row ' + listHeaderGroups.generalRowClassName\">\n            <div *ngFor=\"let listHeader of listHeaderGroup.listHeaders\" [class]=\"listHeader.className\">\n              <span (click)=\"onSort(listHeader.sortProperty)\" [ngClass]=\"{ 'sort-header': listHeader.sortProperty }\">{{ listHeader.displayName }} <i *ngIf=\"sortFields[listHeader.sortProperty] && sortFields[listHeader.sortProperty].icon\" [class]=\"'sort-icon ' + sortFields[listHeader.sortProperty].icon\"></i></span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div> -->\n<!-- <div [class]=\"'row ' + (listHeaderGroups && listHeaderGroups.generalRowClassName) ? listHeaderGroups.generalRowClassName : ''\" *ngFor=\"let item of dataList; trackBy: trackByFn\"> -->\n<div class=\"row\" *ngFor=\"let item of _dataList; trackBy: trackByFn\">\n  <div class=\"col-12\">\n    <lib-item-template-holder\n      [data]=\"item\"\n      [itemComponentClass]=\"itemComponentClass\"\n      [lookups]=\"lookups\"\n      (updateEmitter)=\"_onUpdate($event)\"\n      (updateLookupsEmitter)=\"_onUpdateLookups($event)\"\n      (showModalEmitter)=\"_onShowModal($event)\"\n      (deleteEmitter)=\"_onDelete($event)\">\n    </lib-item-template-holder>\n  </div>\n</div>\n\n<div class=\"row\" *ngIf=\"!_dataCount || _dataCount === 0\">\n  <div class=\"col-12\">\n    <div class=\"row\">\n      <div class=\"col-12 no-results-container\">\n        <div class=\"text-center text-secondary\">\n          <span class=\"italic\">{{ emptyListDisplayText }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n`,\n  styles: [],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class NgEventstoreListingComponent\n  implements OnInit, OnChanges, OnDestroy {\n  @Output() updateEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() updateLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() showModalEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() deleteEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() playbackListLoadedEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() newItemNotifyEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() removedItemNotifyEmitter: EventEmitter<any> = new EventEmitter();\n\n  @Input() itemComponentClass: any;\n  @Input() lookups = {};\n  @Input() socketUrl: string;\n  @Input() playbackListBaseUrl: string;\n  @Input() scriptStore: Script[];\n  @Input() itemSubscriptionConfiguration: SubscriptionConfiguration;\n  @Input() listSubscriptionConfiguration: SubscriptionConfiguration;\n  @Input() playbackListName: string;\n  @Input() filters: Filter[] = null;\n  @Input() sort: Sort = null;\n  @Input() pageIndex = 1;\n  @Input() itemsPerPage: number;\n  @Input() responseBasePath = 'data';\n  @Input() emptyListDisplayText = 'No Results';\n  @Input() csvFileName = '';\n\n  @Input() debugging = false;\n\n  _dataList: Immutable.List<RowItem>;\n  _dataCount: number;\n  _dataTotalCount: number;\n  _initialized = false;\n  _getPlaybackListSubscription: Subscription;\n  _getPlaybackListSubject: Subject<PlaybackListRequest> = new Subject();\n  _exportPlaybackListSubscription: Subscription;\n  _exportPlaybackListSubject: Subject<PlaybackListRequest> = new Subject();\n  _subscriptionTokens: string[] = [];\n  _playbackList: PlaybackList = {\n    get: (rowId: string, callback: (err, item) => void) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      if (rowIndex > -1) {\n        const data = this._dataList.get(rowIndex);\n        if (data) {\n          callback(null, (data as any).toJS());\n        } else {\n          callback(null, {});\n        }\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`), null);\n      }\n    },\n    add: (\n      rowId: string,\n      revision: number,\n      data: any,\n      meta: any,\n      callback: (err?: any) => void\n    ) => {\n      // const newEntry = {\n      //   rowId: rowId,\n      //   revision: revision,\n      //   data: data,\n      //   meta: meta,\n      // };\n      // this.dataList = this.dataList.push(Immutable.fromJS(newEntry));\n      // this.changeDetectorRef.detectChanges();\n      // Do refresh trigger\n      const newItem = {\n        rowId,\n        revision,\n        data,\n        meta\n      };\n      this.newItemNotifyEmitter.emit(newItem);\n      callback();\n    },\n    update: (\n      rowId: string,\n      revision: number,\n      oldData: any,\n      newData: any,\n      meta: any,\n      callback: (err?) => void\n    ) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      // oldData is Immutable\n      const newEntry = Immutable.fromJS({\n        rowId: rowId,\n        revision: revision,\n        data: {\n          ...oldData,\n          ...newData,\n        },\n        meta: meta,\n      });\n\n      if (this.debugging) {\n        console.log(newEntry);\n      }\n\n      if (rowIndex > -1) {\n        if (this.debugging) {\n          console.log(rowIndex);\n          console.log(newEntry);\n\n          console.log(this._dataList.toJS());\n        }\n        this._dataList = this._dataList.set(rowIndex, newEntry);\n\n        if (this.debugging) {\n          console.log(this._dataList.toJS());\n        }\n        this.changeDetectorRef.detectChanges();\n        callback();\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`));\n      }\n    },\n    delete: (rowId: string, callback: (error?: any) => void) => {\n      const rowIndex = this._dataList.findIndex((value: any) => {\n        return value.get('rowId') === rowId;\n      });\n\n      if (rowIndex > -1) {\n        // this._dataList = this._dataList.remove(rowIndex);\n        this.removedItemNotifyEmitter.emit(rowId);\n        callback(null);\n      } else {\n        callback(new Error(`Row with rowId: ${rowIndex} does not exist`));\n      }\n    },\n  };\n\n  _stateFunctions = {\n    getState: (id: string) => {\n      const index = this._dataList.findIndex((row: any) => {\n        return row.get('rowId') === id;\n      });\n      return (this._dataList.get(index) as any).toJS();\n    },\n    setState: (id: string, data: any) => {\n      const index = this._dataList.findIndex((row: any) => {\n        return row.get('rowId') === id;\n      });\n      this._dataList = this._dataList.set(index, Immutable.fromJS(data));\n      this.changeDetectorRef.markForCheck();\n    },\n  };\n\n  constructor(\n    private changeDetectorRef: ChangeDetectorRef,\n    private scriptService: ScriptService,\n    private playbackService: PlaybackService,\n    private playbackListService: PlaybackListService\n  ) {}\n\n  async ngOnInit() {\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const self = this;\n\n    if (!self._initialized) {\n      this._initialized = true;\n      this._loadScripts().then(() => {\n        this._initializeRequests();\n        this.playbackService.init(this.socketUrl);\n\n        const changesKeys = Object.keys(changes);\n        changesKeys.forEach((key) => {\n          self[key] = changes[key].currentValue;\n          switch (key) {\n            case 'pageIndex':\n            case 'filters':\n            case 'sort': {\n              this.requestPlaybackList();\n              break;\n            }\n          }\n        });\n\n      });\n    } else {\n\n      const changesKeys = Object.keys(changes);\n      changesKeys.forEach((key) => {\n        self[key] = changes[key].currentValue;\n        switch (key) {\n          case 'pageIndex':\n          case 'filters':\n          case 'sort': {\n            this.requestPlaybackList();\n            break;\n          }\n        }\n      });\n    }\n  }\n\n\n  ngOnDestroy() {\n    this._resetSubscriptions();\n  }\n\n  trackByFn(index: number, item: any) {\n    return item.get('rowId');\n  }\n\n  private _initializeRequests(): void {\n    this._getPlaybackListSubscription = this._getPlaybackListSubject\n      .pipe(\n        debounceTime(100),\n        switchMap((params) => {\n          return this.playbackListService.getPlaybackList(\n            this.playbackListBaseUrl,\n            params.playbackListName,\n            params.startIndex,\n            params.limit,\n            params.filters,\n            params.sort\n          );\n        })\n      )\n      .subscribe((res: any) => {\n        this._dataList = Immutable.fromJS(res.rows);\n        this._dataCount = res.rows.length;\n        this._dataTotalCount = res.count;\n\n        this._resetSubscriptions();\n        this._initSubscriptions();\n\n        this.changeDetectorRef.detectChanges();\n\n        this.playbackListLoadedEmitter.emit({\n          totalItems: this._dataTotalCount,\n          dataCount: this._dataCount,\n        });\n      });\n\n    this._exportPlaybackListSubscription = this._exportPlaybackListSubject\n    .pipe(\n      debounceTime(100),\n      switchMap((params) => {\n        return this.playbackListService.getPlaybackListCsv(\n          this.playbackListBaseUrl,\n          params.playbackListName,\n          params.startIndex,\n          params.limit,\n          params.filters,\n          params.sort\n        );\n      })\n    )\n    .subscribe((result: any) => {\n      const csv = new Blob([result], { type: 'text/csv' });\n      const moment = moment_;\n      const now = moment();\n      const fileName = `${now.format('YYYY_MM_DD_HH_mm_ss')}_${this.csvFileName || this.playbackListName}.csv`;\n      saveAs(csv, fileName);\n    });\n  }\n\n  _getPlaybackList(\n    playbackListName: string,\n    startIndex: number,\n    limit: number,\n    filters?: Filter[],\n    sort?: Sort\n  ) {\n    const playbackListRequestParams: PlaybackListRequest = {\n      playbackListName: playbackListName,\n      startIndex: startIndex,\n      limit: limit,\n      filters: filters,\n      sort: sort,\n    };\n    this._getPlaybackListSubject.next(playbackListRequestParams);\n  }\n\n  requestPlaybackList() {\n    const startIndex = this.itemsPerPage * (this.pageIndex - 1);\n    this._getPlaybackList(\n      this.playbackListName,\n      startIndex,\n      this.itemsPerPage,\n      this.filters,\n      this.sort\n    );\n  }\n\n  private async _loadScripts() {\n    if (this.scriptStore) {\n      await this.scriptService.init(this.scriptStore);\n    }\n  }\n\n  private async _initSubscriptions() {\n    const self = this;\n    // Per row subscriptions\n    if (self.itemSubscriptionConfiguration) {\n      self._dataList.forEach(async (row: any) => {\n        const query: Query = _clone(self.itemSubscriptionConfiguration.query);\n        query.aggregateId = query.aggregateId.replace(\n          /{{rowId}}/g,\n          row.get('rowId')\n        );\n        this._subscriptionTokens.push(\n          await self.playbackService.registerForPlayback(\n            self.itemSubscriptionConfiguration.playbackScriptName,\n            self,\n            query,\n            self._stateFunctions,\n            row.get('revision') + 1,\n            self._playbackList\n          )\n        );\n      });\n    }\n\n    if (self.listSubscriptionConfiguration) {\n      // List subscription\n      this._subscriptionTokens.push(\n        await self.playbackService.registerForPlayback(\n          self.listSubscriptionConfiguration.playbackScriptName,\n          self,\n          self.listSubscriptionConfiguration.query,\n          self._stateFunctions,\n          // TODO: Revision response from getPlaybackList\n          0,\n          self._playbackList\n        )\n      );\n    }\n  }\n\n  private _resetSubscriptions() {\n    this._subscriptionTokens.forEach((subscriptionToken) => {\n      this.playbackService.unRegisterForPlayback(subscriptionToken);\n    });\n    this._subscriptionTokens = [];\n  }\n\n  _onUpdate(payload: any) {\n    this.updateEmitter.emit(payload);\n  }\n\n  _onUpdateLookups(payload: any) {\n    this.updateLookupsEmitter.emit(payload);\n  }\n\n  _onShowModal(payload: any) {\n    this.showModalEmitter.emit(payload);\n  }\n\n  _onDelete(payload: any) {\n    this.deleteEmitter.emit(payload);\n  }\n\n  exportCSV() {\n    const startIndex = this.itemsPerPage * (this.pageIndex - 1);\n    const exportPlaybackListRequestParams: PlaybackListRequest = {\n      playbackListName: this.playbackListName,\n      startIndex: startIndex,\n      limit: 1000000,\n      filters: this.filters,\n      sort: this.sort,\n    };\n\n    this._exportPlaybackListSubject.next(exportPlaybackListRequestParams);\n  }\n}\n",
    "import { Directive, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[libTemplateDirective]'\n})\nexport class TemplateDirective {\n  constructor(public viewContainerRef: ViewContainerRef) { }\n}\n",
    "import {\n  Component,\n  OnInit,\n  Input,\n  ViewChild,\n  ComponentFactoryResolver,\n  Output,\n  EventEmitter,\n  OnChanges,\n  ComponentRef,\n  SimpleChanges,\n  ChangeDetectionStrategy,\n  AfterViewInit,\n} from '@angular/core';\nimport { ItemTemplateComponent } from '../template-components/index';\nimport { TemplateDirective } from '../../directives/template.directive';\n\n@Component({\n  selector: 'lib-item-template-holder',\n  template: `<div class=\"row no-gutters\">\n  <div class=\"col-12\">\n    <ng-template libTemplateDirective></ng-template>\n  </div>\n</div>\n`,\n  styles: [``],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ItemTemplateHolderComponent\n  implements OnInit, OnChanges, AfterViewInit {\n  @Input() itemComponentClass: any;\n  @Input() data: any = {};\n  @Input() lookups: any = {};\n  @Output() updateEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() updateLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() showModalEmitter: EventEmitter<any> = new EventEmitter();\n  @Output() deleteEmitter: EventEmitter<any> = new EventEmitter();\n\n  componentRef: ComponentRef<any>;\n  initialChanges: SimpleChanges;\n  @ViewChild(TemplateDirective) itemHost: TemplateDirective;\n\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}\n\n  ngOnInit(): void {\n    // this.loadComponent();\n  }\n\n  ngAfterViewInit(): void {\n    this.loadComponent();\n    if (this.initialChanges) {\n      this.ngOnChanges(this.initialChanges);\n      this.initialChanges = undefined;\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const self = this;\n    if (self.componentRef) {\n      const changesKeys = Object.keys(changes);\n      changesKeys.forEach((key) => {\n        (self.componentRef.instance as ItemTemplateComponent)[key] =\n          changes[key].currentValue;\n      });\n      (self.componentRef.instance as ItemTemplateComponent).ngOnChanges(\n        changes\n      );\n    } else {\n      this.initialChanges = changes;\n    }\n  }\n\n  loadComponent(): void {\n    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(\n      this.itemComponentClass\n    );\n    const viewContainerRef = this.itemHost.viewContainerRef;\n    viewContainerRef.clear();\n\n    this.componentRef = viewContainerRef.createComponent(componentFactory);\n    (this.componentRef.instance as ItemTemplateComponent).data = this.data;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onUpdateEmitter = this.updateEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onUpdateLookupsEmitter = this.updateLookupsEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onShowModalEmitter = this.showModalEmitter;\n    (this.componentRef\n      .instance as ItemTemplateComponent).onDeleteEmitter = this.deleteEmitter;\n    // (this.componentRef.instance as ItemTemplateComponent).idPropertyName = this.idPropertyName;\n    (this.componentRef\n      .instance as ItemTemplateComponent).lookups = this.lookups;\n    (this.componentRef.instance as ItemTemplateComponent).ngOnInit();\n  }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { NgEventstoreListingComponent } from './ng-eventstore-listing.component';\nimport { ItemTemplateHolderComponent } from './components/item-template-holder/item-template-holder.component';\n\nimport { CommonModule } from '@angular/common';\nimport { TemplateDirective } from './directives/template.directive';\nimport { IO_TOKEN } from './services/socket.io.service';\n\nimport * as io from 'socket.io-client';\nimport { ScriptService } from './services/script.service';\nimport { PlaybackService } from './services/playback.service';\nimport { PlaybackListService } from './services/playback-list.service';\nimport { PushService } from './services/push.service';\n\n@NgModule({\n  declarations: [\n    NgEventstoreListingComponent,\n    ItemTemplateHolderComponent,\n    TemplateDirective,\n\n  ],\n  imports: [CommonModule],\n  exports: [\n    NgEventstoreListingComponent\n  ],\n  providers: [\n    ScriptService,\n    PlaybackService,\n    PlaybackListService,\n    PushService,\n    { provide: IO_TOKEN, useValue: io }\n  ]\n})\nexport class NgEventstoreListingModule {}\n",
    "import {\n  EventEmitter,\n  OnInit,\n  OnChanges,\n  SimpleChanges,\n  ChangeDetectorRef,\n} from '@angular/core';\n\nexport abstract class ItemTemplateComponent implements OnInit, OnChanges {\n  // Event Emitters\n  onUpdateEmitter: EventEmitter<any> = new EventEmitter();\n  onUpdateLookupsEmitter: EventEmitter<any> = new EventEmitter();\n  onShowModalEmitter: EventEmitter<any> = new EventEmitter();\n  onDeleteEmitter: EventEmitter<any> = new EventEmitter();\n\n  idPropertyName: string;\n  data: any; // Immutable item\n  lookups: any;\n\n  _changeFn: (changes) => void;\n\n  constructor(protected changeDetectorRef?: ChangeDetectorRef) {}\n\n  ngOnInit(): void {}\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (this._changeFn) {\n      this._changeFn(changes);\n    }\n\n    if (this.changeDetectorRef) {\n      this.changeDetectorRef.detectChanges();\n    }\n  }\n\n  registerChangeFunction = (changeFn: (changes) => void) => {\n    this._changeFn = changeFn;\n  }\n\n  onUpdate = (propertyName: string, actionData: any) => {\n    const actionEventEmitterData = {\n      propertyName: propertyName,\n      id: this.data.get(this.idPropertyName),\n      data: actionData,\n    };\n    this.onUpdateEmitter.emit(actionEventEmitterData);\n  }\n\n  onUpdateLookups = (lookup) => {\n    const actionEventEmitterData = {\n      lookup: lookup,\n    };\n    this.onUpdateLookupsEmitter.emit(actionEventEmitterData);\n  }\n\n  onShowModal = (modalName, data) => {\n    const actionEventEmitterData = {\n      modalName: modalName,\n      id: this.data.get(this.idPropertyName),\n      data: data,\n    };\n    this.onShowModalEmitter.emit(actionEventEmitterData);\n  }\n\n  onDelete = (actionData?: any) => {\n    const actionEventEmitterData = {\n      id: this.data.get(this.idPropertyName),\n      data: actionData,\n    };\n    this.onDeleteEmitter.emit(actionEventEmitterData);\n  }\n}\n",
    "export enum FilterOperator {\n  range = 'range',\n  is = 'is',\n  any = 'any',\n  contains = 'contains',\n  endsWith = 'endsWith',\n  startsWith = 'startsWith',\n  arrayContains = 'arrayContains',\n}\n",
    "export enum SortDirection {\n  ASC = 'ASC',\n  DESC = 'DESC',\n}\n",
    "export enum GroupBooleanOperator {\n  and = 'and',\n  or = 'or'\n}\n"
  ],
  "names": [
    "__awaiter",
    "thisArg",
    "_arguments",
    "P",
    "generator",
    "Promise",
    "resolve",
    "reject",
    "fulfilled",
    "value",
    "step",
    "next",
    "e",
    "rejected",
    "result",
    "done",
    "adopt",
    "then",
    "apply",
    "__generator",
    "body",
    "f",
    "y",
    "t",
    "g",
    "_",
    "label",
    "sent",
    "trys",
    "ops",
    "verb",
    "throw",
    "return",
    "Symbol",
    "iterator",
    "this",
    "n",
    "v",
    "op",
    "TypeError",
    "call",
    "pop",
    "length",
    "push",
    "ScriptService",
    "scripts",
    "prototype",
    "init",
    "scriptStore",
    "promises",
    "forEach",
    "script",
    "_this",
    "name",
    "loaded",
    "src",
    "meta",
    "load",
    "all",
    "_a",
    "_i",
    "arguments",
    "loadScript",
    "console",
    "log",
    "status",
    "document",
    "querySelectorAll",
    "script_1",
    "createElement",
    "type",
    "readyState",
    "onreadystatechange",
    "onload",
    "onerror",
    "error",
    "getElementsByTagName",
    "appendChild",
    "getScript",
    "scriptName",
    "Injectable",
    "IO_TOKEN",
    "InjectionToken",
    "PushService",
    "io",
    "ngZone",
    "subscriptions",
    "socketUrl",
    "ioPush",
    "self",
    "on",
    "eventObj",
    "token",
    "Object",
    "keys",
    "clientToken",
    "sub",
    "isNaN",
    "streamRevision",
    "offset",
    "cb",
    "undefined",
    "owner",
    "monitorTags",
    "tag",
    "_meta",
    "reason_1",
    "eventType",
    "stateType",
    "eventSource",
    "monitor",
    "callback",
    "subscribe",
    "query",
    "Math",
    "random",
    "toString",
    "substr",
    "Date",
    "now",
    "subscriptionQuery_1",
    "assign",
    "emit",
    "unsubscribe",
    "connected",
    "decorators",
    "Inject",
    "args",
    "NgZone",
    "PlaybackService",
    "scriptService",
    "pushService",
    "playbackRegistry",
    "playbackInterfaceMap",
    "unRegisterForPlayback",
    "registerForPlayback",
    "stateFunctions",
    "playbackList",
    "playbackScript",
    "window",
    "objectName",
    "err",
    "owner2",
    "registration",
    "context",
    "scriptName_1",
    "fromEvent",
    "payload",
    "eventName",
    "playbackFunction",
    "playbackInterface",
    "getState",
    "aggregateId",
    "data",
    "targetQuery",
    "getPlaybackList",
    "playbackListName",
    "Error",
    "scriptName_2",
    "subscriptionId",
    "registrationId",
    "PlaybackListService",
    "http",
    "playbackListBaseUrl",
    "startIndex",
    "limit",
    "filters",
    "sort",
    "url",
    "JSON",
    "stringify",
    "get",
    "getPlaybackListCsv",
    "HttpClient",
    "NgEventstoreListingComponent",
    "changeDetectorRef",
    "playbackService",
    "playbackListService",
    "updateEmitter",
    "EventEmitter",
    "updateLookupsEmitter",
    "showModalEmitter",
    "deleteEmitter",
    "playbackListLoadedEmitter",
    "newItemNotifyEmitter",
    "removedItemNotifyEmitter",
    "lookups",
    "pageIndex",
    "responseBasePath",
    "emptyListDisplayText",
    "csvFileName",
    "debugging",
    "_initialized",
    "_getPlaybackListSubject",
    "Subject",
    "_exportPlaybackListSubject",
    "_subscriptionTokens",
    "_playbackList",
    "rowId",
    "rowIndex",
    "_dataList",
    "findIndex",
    "toJS",
    "add",
    "revision",
    "newItem",
    "update",
    "oldData",
    "newData",
    "newEntry",
    "Immutable.fromJS",
    "set",
    "detectChanges",
    "delete",
    "_stateFunctions",
    "id",
    "index",
    "row",
    "setState",
    "markForCheck",
    "ngOnInit",
    "ngOnChanges",
    "changes",
    "key",
    "currentValue",
    "requestPlaybackList",
    "_loadScripts",
    "_initializeRequests",
    "ngOnDestroy",
    "_resetSubscriptions",
    "trackByFn",
    "item",
    "_getPlaybackListSubscription",
    "pipe",
    "debounceTime",
    "switchMap",
    "params",
    "res",
    "rows",
    "_dataCount",
    "_dataTotalCount",
    "count",
    "_initSubscriptions",
    "totalItems",
    "dataCount",
    "_exportPlaybackListSubscription",
    "csv",
    "Blob",
    "fileName",
    "moment_",
    "format",
    "saveAs",
    "_getPlaybackList",
    "playbackListRequestParams",
    "itemsPerPage",
    "itemSubscriptionConfiguration",
    "tslib_1.__awaiter",
    "_clone",
    "replace",
    "_b",
    "playbackScriptName",
    "_c",
    "listSubscriptionConfiguration",
    "subscriptionToken",
    "_onUpdate",
    "_onUpdateLookups",
    "_onShowModal",
    "_onDelete",
    "exportCSV",
    "exportPlaybackListRequestParams",
    "Component",
    "selector",
    "template",
    "styles",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "ChangeDetectorRef",
    "Output",
    "itemComponentClass",
    "Input",
    "TemplateDirective",
    "viewContainerRef",
    "Directive",
    "ViewContainerRef",
    "ItemTemplateHolderComponent",
    "componentFactoryResolver",
    "ngAfterViewInit",
    "loadComponent",
    "initialChanges",
    "componentRef",
    "componentFactory",
    "resolveComponentFactory",
    "itemHost",
    "clear",
    "createComponent",
    "onUpdateEmitter",
    "onUpdateLookupsEmitter",
    "onShowModalEmitter",
    "onDeleteEmitter",
    "ComponentFactoryResolver",
    "ViewChild",
    "ɵ0",
    "NgEventstoreListingModule",
    "NgModule",
    "declarations",
    "imports",
    "CommonModule",
    "exports",
    "providers",
    "provide",
    "useValue",
    "ItemTemplateComponent",
    "registerChangeFunction",
    "changeFn",
    "_changeFn",
    "onUpdate",
    "propertyName",
    "actionData",
    "actionEventEmitterData",
    "idPropertyName",
    "onUpdateLookups",
    "lookup",
    "onShowModal",
    "modalName",
    "onDelete",
    "range",
    "is",
    "any",
    "contains",
    "endsWith",
    "startsWith",
    "arrayContains",
    "ASC",
    "DESC",
    "and",
    "or"
  ],
  "mappings": "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"
}
